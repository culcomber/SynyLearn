## 1、函数

### call

```js
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}
```

### apply

```js
Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
}
```

### bind

```js
Function.prototype.bind2 = function (context) {
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

### new

```js
function objectFactory() {
    var obj = new Object(),

    Constructor = [].shift.call(arguments);

    obj.__proto__ = Constructor.prototype;

    var ret = Constructor.apply(obj, arguments);

    return typeof ret === 'object' ? ret : obj;
};
```

## 2、对象

### 对象的拷贝

获得对象的所有属性（不管是自身的还是继承的，也不管是否可遍历）

```js
function inheritedPropertyNames(obj) {
  var props = {};
  while(obj) {
    // 遍历自身所有属性，包括不可以遍历
    Object.getOwnPropertyNames(obj).forEach(function(p) {
      props[p] = true;
    });
    obj = Object.getPrototypeOf(obj); // 返回对象原型
  }
  return Object.getOwnPropertyNames(props);
}
```

- 确保拷贝后的对象，与原对象具有同样的原型
- 确保拷贝后的对象，与原对象具有同样的实例属性

```js
function copyObject(orig) {
    // 获取orig原型，确保拷贝后的对象，与原对象具有同样的原型
    var copy = Object.create(Object.getPrototypeOf(orig)); 
    copyOwnPropertiesFrom(copy, orig);
    return copy;
}
function copyOwnPropertiesFrom(target, source) {
    // 拷贝对象所有属性
    Object
        .getOwnPropertyNames(source)
        .forEach(function (propKey) {
        	// 获取拷贝对象的属性描述
            var desc = Object.getOwnPropertyDescriptor(source, propKey);
        	// 新对象赋值拷贝的属性
            Object.defineProperty(target, propKey, desc);
        });
    return target;
}

//  ES2017引入标准的Object.getOwnPropertyDescriptors方法
function copyObject(orig) {
  return Object.create(
    Object.getPrototypeOf(orig),
    Object.getOwnPropertyDescriptors(orig)
  );
}
```

### 对象的继承

```js
// 父类
function Shape() {
  this.x = 0;
  this.y = 0;
}
Shape.prototype.move = function (x, y) {
  this.x += x;
  this.y += y;
  console.info('Shape moved.');
};

// 第一步，子类继承父类的实例
function Rectangle() {
  // 使用new调用Rectangle，会创建一个新对象（this），执行下面语句，给对象增加Shape的属性
  Shape.call(this); // 调用父类构造函数
}
// 另一种写法
function Rectangle() {
  this.base = Shape;
  this.base();
}

// 第二步，子类继承父类的原型
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

var rect = new Rectangle();
rect instanceof Rectangle  // true
rect instanceof Shape  // true
```

**只需要单个方法的继承**

```js
// 子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法
ClassB.prototype.print = function() {
  ClassA.prototype.print.call(this);
  // some code
}
```

**多重继承**

`JavaScript` 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。

```js
// 子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）
function M1() {
  this.hello = 'hello';
}
function M2() {
  this.world = 'world';
}
function S() {
  M1.call(this);
  M2.call(this);
}

// 继承 M1
S.prototype = Object.create(M1.prototype);
// 继承链上加入 M2
Object.assign(S.prototype, M2.prototype);
/* const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
Object.assign(target, source); // { a: 1, b: 4, c: 5 }*/
// 指定构造函数
S.prototype.constructor = S;

var s = new S();
s.hello // 'hello'
s.world // 'world'
```

### 尾递归优化

```js
function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    console.log(arguments)
    if (!active) {
      active = true;
      console.log(active)
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      console.log(active)
      return value; // return sum(x + 1, y - 1) --> accumulator(x + 1, y - 1)
    }
  };
}
var sum = tco(function(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1)
  } else {
    return x
  }
});

const hello = sum(1, 3) // 100001
console.log(hello)
/*[Arguments] { '0': 1, '1': 3 } 
--- accumulated放入参数，active=false进入if，进入while，执行f-->sum，返回return sum(x + 1, y - 1)
--- 由于 sum(2, 2) --> accumulator(2, 2) value实际等于accumulator(2, 2)，即再次执行accumulator(2, 2)
true                          
[Arguments] { '0': 2, '1': 2 } 
--- accumulated放入参数，active=true不进入if，但是accumulator(1, 3)的循环不能结束，因为accumulated有新参数[2,2]
[Arguments] { '0': 3, '1': 1 }
--- 同上accumulated有新参数[3,1]
[Arguments] { '0': 4, '1': 0 }
--- 同上accumulated有新参数[4,0]，此时value=4，不是函数，accumulated参数不是增加，结束循环
false                         
4   */
```

## 3、Promise

### Ajax

```js
const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    client.send();
  });
  return promise;
};

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
```

## 4、数组



## 5、字符串
