### call

```js
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}
```

### apply

```js
Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
}
```

### bind

```js
Function.prototype.bind2 = function (context) {
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

### new

```js
function objectFactory() {
    var obj = new Object(),

    Constructor = [].shift.call(arguments);

    obj.__proto__ = Constructor.prototype;

    var ret = Constructor.apply(obj, arguments);

    return typeof ret === 'object' ? ret : obj;
};
```

### 对象的拷贝
获得对象的所有属性（不管是自身的还是继承的，也不管是否可遍历）

```js
function inheritedPropertyNames(obj) {
  var props = {};
  while(obj) {
    // 遍历自身所有属性，包括不可以遍历
    Object.getOwnPropertyNames(obj).forEach(function(p) {
      props[p] = true;
    });
    obj = Object.getPrototypeOf(obj); // 返回对象原型
  }
  return Object.getOwnPropertyNames(props);
}
```

- 确保拷贝后的对象，与原对象具有同样的原型
- 确保拷贝后的对象，与原对象具有同样的实例属性

```js
function copyObject(orig) {
    // 获取orig原型，确保拷贝后的对象，与原对象具有同样的原型
    var copy = Object.create(Object.getPrototypeOf(orig)); 
    copyOwnPropertiesFrom(copy, orig);
    return copy;
}
function copyOwnPropertiesFrom(target, source) {
    // 拷贝对象所有属性
    Object
        .getOwnPropertyNames(source)
        .forEach(function (propKey) {
        	// 获取拷贝对象的属性描述
            var desc = Object.getOwnPropertyDescriptor(source, propKey);
        	// 新对象赋值拷贝的属性
            Object.defineProperty(target, propKey, desc);
        });
    return target;
}

//  ES2017引入标准的Object.getOwnPropertyDescriptors方法
function copyObject(orig) {
  return Object.create(
    Object.getPrototypeOf(orig),
    Object.getOwnPropertyDescriptors(orig)
  );
}
```
