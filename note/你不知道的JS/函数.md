## 1、变量的解构赋值

`ES6` 允许按照一定模式，从数组和对象中提取值，对变量进行赋值

### 1.1 数组的解构赋值

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
// foo = 1 bar = 2 baz = 3

let [ , , third] = ["foo", "bar", "baz"];
// third = "baz"

let [x, , y] = [1, 2, 3];
// x = 1 y = 3

let [head, ...tail] = [1, 2, 3, 4];
// head = 1 tail = [2, 3, 4]

// 如果解构不成功，变量的值就等于undefined
let [x, y, ...z] = ['a'];
// x = "a" y = undefined z = []
```

事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```js
let [foo] = 1; // 报错

function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}
let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
```

**默认值** 

`ES6` 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。

```js
let [x = 1] = [undefined]; // x = 1
let [x = 1] = [null]; // x = null null不严格等于undefined

// 表达式是惰性求值，x能取到值，所以函数f根本不会执行
function f() {
  console.log('aaa');
}
let [x = f()] = [1];
```

### 1.2 对象的解构赋值

数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```js
let { foo, bar, baz } = { foo: 'aaa', bar: 'bbb' }; // foo = "aaa"  bar = "bbb"  baz = undefined

// 方便地将现有对象的方法，赋值到某个变量
const { log } = console;
log('hello') // hello

// 变量名与属性名，真正被赋值的是后者，而不是前者
let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; // baz = "aaa"
// 对象的解构赋值是下面形式的简写
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };

// 用于嵌套结构的对象
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};
let { p, p: [x, { y }] } = obj;
// x = "Hello" y = "World" p = ["Hello", {y: "World"}]

// 对象的解构赋值可以取到继承的属性
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);
const { foo } = obj1;
foo // "bar"
```

注意点
（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。

（2）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

```js
// 错误的写法
let x;
{x} = {x: 1}; // SyntaxError: syntax error JavaScript引擎将{x}理解成一个代码块
// 正确的写法
let x;
({x} = {x: 1});

let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr; // first = 1 last = 3
```

### 1.3 基本类型的解构赋值

**字符串的解构赋值**

字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。

```js
const [a, b, c, d, e] = 'hello';
// a = "h" b = "e" c = "l" d = "l" e = "o"

let {length : len} = 'hello'; // len = 5 类似数组的对象都有一个length属性
```

**数值和布尔值的解构赋值**

等号右边是数值和布尔值，则会先转为对象。

```js
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```

**undefined和null**

只要等号右边的值不是对象或数组，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

```js
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```

### 1.4 函数参数的解构赋值

```js
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
```



圆括号问题



用途





函数的扩展

函数参数的默认值

rest 参数

严格模式

name 属性

箭头函数

尾调用优化

函数参数的尾逗号

Function.prototype.toString()

catch 命令的参数省略





递归和堆栈



Rest 参数与 Spread 语法

变量作用域，闭包

老旧的 "var"

全局对象

函数对象，NFE

"new Function" 语法

调度：setTimeout 和 setInterval

装饰器模式和转发，call/apply

函数绑定

深入理解箭头函数

