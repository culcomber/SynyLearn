## 1、异步操作

JS是单线程，异步任务防止阻塞，异步操作的模式 

- 回调函数
- 事件监听
- 发布/订阅

```js
function f1(callback) { callback(); }
function f2() { ... }
f1(f2);
               
f1.on('done', f2);
function f1() {
  setTimeout(function () {
    // ...
    f1.trigger('done');
  }, 1000);
}
               
jQuery.subscribe('done', f2);
function f1() {
  setTimeout(function () {
    // ...
    jQuery.publish('done');
  }, 1000);
}
jQuery.unsubscribe('done', f2);
```

## 2、定时器

### 2.1 setTimeout(func|code, delay)

code是字符串，delay省略默认为0

```js
// delay后可以接受参数
setTimeout(function (a,b) {
  console.log(a + b);
}, 1000, 1, 1);

// setTimeout内回调函数this指向全局
var x = 1;
var obj = {
  x: 2,
  y: function () {
    console.log(this.x);
  }
};wo
obj.y() // 2
setTimeout(obj.y, 1000) // 1
setTimeout(function () {
  obj.y();
}, 1000); // 2
setTimeout(obj.y.bind(obj), 1000) // 2
```

`setTimeout(f, 0)`不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。

- 可以调整事件的发生顺序
- 用户自定义的回调函数，通常在浏览器的默认动作之前触发
- 计算量大、耗时长的任务，常常会被放到几个小部分，分别放到`setTimeout(f, 0)`里面执行。

```js
// 在用户每次输入文本后，立即将字符转为大写
// HTML 代码如下
// <input type="text" id="input-box">
document.getElementById('input-box').onkeypress = function (event) {
  this.value = this.value.toUpperCase(); // 浏览器此时还没接收到新的文本
}

document.getElementById('input-box').onkeypress = function() {
  var self = this;
  setTimeout(function() {
    self.value = self.value.toUpperCase();
  }, 0);
}

// 改变一个网页元素的背景色
var div = document.getElementsByTagName('div')[0];
// 写法一
for (var i = 0xA00000; i < 0xFFFFFF; i++) {
  div.style.backgroundColor = '#' + i.toString(16);
}
// 写法二
var timer;
var i=0x100000;
function func() {
  timer = setTimeout(func, 0);
  div.style.backgroundColor = '#' + i.toString(16);
  if (i++ == 0xFFFFFF) clearTimeout(timer);
}
timer = setTimeout(func, 0);
```

### 2.2 setInterval()

无限次的定时执行

`setInterval`指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。

为了确保两次执行之间有固定的间隔，可以不用`setInterval`，而是每次执行结束后，使用`setTimeout`指定下一次执行的具体时间。

```js
var i = 1;
var timer = setTimeout(function f() {
  // ...
  timer = setTimeout(f, 2000);
}, 2000);

// 生效后setInterval不会产生累积效应
setInterval(function () {
  console.log(2);
}, 1000);
sleep(3000);
function sleep(ms) {
  var start = Date.now();
  while ((Date.now() - start) < ms) {
  }
}
```

### 2.3 clearTimeout()，clearInterval()

`setTimeout`和`setInterval`函数，都返回一个整数值，表示计数器编号。将该整数传入`clearTimeout`和`clearInterval`函数，就可以取消对应的定时器。

返回的整数值是连续的，也就是说，第二个`setTimeout`方法返回的整数值，将比第一个的整数值大1。

```js
(function() {
  // 每轮事件循环检查一次
  var gid = setInterval(clearAllTimeouts, 0);

  function clearAllTimeouts() {
    var id = setTimeout(function() {}, 0);
    while (id > 0) {
      if (id !== gid) {
        clearTimeout(id);
      }
      id--;
    }
  }
})();
```

## 3、Promise 对象

- 只有**异步操作的结果**，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
- 一旦状态改变，就**不会再变**，任何时候都可以得到这个结果。
- 无法**取消**`Promise`，一旦新建它就会立即执行，无法中途取消
- 如果不设置回调函数，`Promise`内部抛出的**错误**，不会反应到外部。

### 3.1 基本用法

```JS
// Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject
const promise = new Promise(function(resolve, reject) {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value); // resolve函数的作用是将Promise对象的状态从“未完成”变为“成功”（从 pending变为resolved），并将异步操作的结果，作为参数传递出去
  } else {
    reject(error); // reject函数的作用是将Promise对象的状态从“未完成”变为“失败”（从 pending 变为 rejected），并将异步操作报出的错误，作为参数传递出去
  }
});

// Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});

// 实例
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});
promise.then(function() {
  console.log('resolved.');
});
console.log('Hi!');
// Promise Hi! resolved
```

**用`Promise`对象实现的 Ajax 操作的例子**

```js
const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    client.send();

  });

  return promise;
};

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
```

**reject()方法的作用，等同于抛出错误**

```js
// 三种写法是等价的
const promise = new Promise(function(resolve, reject) {
  throw new Error('test');
});
const promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
const promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});

promise.catch(function(error) {
  console.log(error);
}); // Error: test
```

**Promise 的状态一旦改变，就永久保持该状态，不会再变了**

```js
const promise = new Promise(function(resolve, reject) {
  resolve('ok');
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
```

**p1的状态就会传递给p2**

```js
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// Error: fail
```

### 3.2 then/catch/finally

**为 Promise 实例添加状态改变时的回调函数**

**Promise.prototype.then()**

then方法返回的是一个新的Promise实例

**Promise.prototype.catch()**

是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数

`catch()`方法返回的还是一个 Promise 对象

then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获

```js
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
}).catch(function(error) {
  console.log('carry on', error); // 可以捕获上一个catch运行的错误，但如果此时发生错误，则没有办法捕抓，因为后面没有catch
});
```

Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。

如果没有使用`catch()`方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。

```js
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明，浏览器会打印出错误提示，但是不会退出进程、终止脚本执行
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  console.log('everything is great');
});

setTimeout(() => { console.log(123) }, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
```

**Promise.prototype.finally()**

用于指定不管 Promise 对象最后状态如何，都会执行的操作

```js
promise = new Promise(function(resolve, reject) {
    resolve('app');
})
promise
    .then(result => {console.log(result)})
    .catch(error => {console.log(error)})
    .finally(() => {console.log('finally')}); // 不能接收参数
// app finally

// 实现
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  => P.resolve(callback()).then(() => value),
    reason => P.resolve(callback()).then(() => { throw reason })
  );
};
```

### 3.3 resolve/reject

**将现有对象转为 Promise 对象**

**Promise.resolve()**

```js
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

（1）参数是一个 Promise 实例：不做任何修改、原封不动地返回这个实例

（2）参数是一个thenable对象：`thenable`对象指的是具有`then`方法的对象，会将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then()`方法。

```js
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function (value) {
  console.log(value);  // 42
});
```

（3）参数不是具有then()方法的对象，或根本就不是对象：返回一个新的 Promise 对象，状态为`resolved`，`Promise.resolve()`方法的参数，会同时传给回调函数。

**Promise.reject()**

`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数

```js
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'))
p.then(null, function (s) {
  console.log(s)
}); // 出错了
```

### 3.4 all/race/allSettled/any

**将多个 Promise 包装成新的 Promise**

**Promise.all()**

`const p = Promise.all([p1, p2, p3]);`

（1）只有`p1`、`p2`、`p3`的状态**都变成`fulfilled`**，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。

（2）只要`p1`、`p2`、`p3`之中有**一个被`rejected`**，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。

实例：`booksPromise`和`userPromise`是两个异步操作，只有等到它们的结果都返回了，才会触发`pickTopRecommendations`这个回调函数

```js
const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) => pickTopRecommendations(books, user));
```

Promise 实例定义了`catch`方法或者`then`中指定`reject`函数，那么它一旦被`rejected`，并不会触发`Promise.all()`的`catch`方法

```js
const p1 = new Promise((resolve, reject) => {
  resolve('hello');
})
.then(result => result, reject => reject);

const p2 = new Promise((resolve, reject) => {
  throw new Error('报错了');
})
.then(result => result)
.catch(e => e); // 处理throw new Error并返回新的promise，状态为resolved

Promise.all([p1, p2])
.then(result => console.log(result))
.catch(e => console.log(e)); // 如果p2没有catch，就会执行到这里
// ["hello", Error: 报错了]
```

**Promise.race()**

只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。

实例：如果 5 秒之内`fetch`方法无法返回结果，变量`p`的状态就会变为`rejected`，从而触发`catch`方法指定的回调函数。

```js
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
```

**Promise.allSettled()**

只有等到参数数组的所有 Promise 对象都发生状态变更（不管是`fulfilled`还是`rejected`），返回的 Promise 对象才会发生状态变更。

该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是`fulfilled`，不会变成`rejected`。

回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。

```js
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);
const allSettledPromise = Promise.allSettled([resolved, rejected]);
allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]

const promises = [ fetch('index.html'), fetch('https://does-not-exist/') ];
const results = await Promise.allSettled(promises);
// 过滤出成功的请求
const successfulPromises = results.filter(p => p.status === 'fulfilled');
// 过滤出失败的请求，并输出原因
const errors = results
  .filter(p => p.status === 'rejected')
  .map(p => p.reason);
```

**Promise.any()**

只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。

```js
var resolved = Promise.resolve(42);
var rejected = Promise.reject(-1);
var alsoRejected = Promise.reject(Infinity);

Promise.any([resolved, rejected, alsoRejected]).then(function (result) {
  console.log(result); // 42
});

Promise.any([rejected, alsoRejected]).catch(function (results) {
  console.log(results instanceof AggregateError); // true
  console.log(results.errors); // [-1, Infinity]
});
```

### 3.5 Generator 函数与 Promise 的结合

使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个`Promise`对象。

Generator 函数`g`之中，有一个异步操作`getFoo`，它返回的就是一个`Promise`对象。函数`run`用来处理这个`Promise`对象，并调用下一个`next`方法。

```javascript
function getFoo () {
    return new Promise(function (resolve, reject){
        resolve('foo');
    });
}

const g = function* () {
    try {
        const foo = yield getFoo();
        console.log(foo);
    } catch (e) {
        console.log(e);
    }
};

function run (generator) {
    const it = generator(); // 得到g迭代器

    function go(result) { // 参数是it
        // { value: Promise { 'foo' }, done: false }
        // { value: undefined, done: true }
        if (result.done) return result.value;

        return result.value.then(function (value) { // g还有yield就继续调用
            return go(it.next(value));
        }, function (error) {
            return go(it.throw(error));
        });
    }

    go(it.next()); // 运行g
}

run(g);
```

## 4、Iterator 和 for...of 循环

### 4.1 Iterator（遍历器）的概念

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

Iterator 的遍历过程是这样的。

（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

（2）第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员，并返回一个包含`value`和`done`两个属性的对象。其中，`value`属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。

（3）第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。

（4）不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。

```js
var it = makeIterator(['a', 'b']); // it遍历器对象
// next方法，用来移动指针，并返回一个对象，表示当前数据成员的信息。
it.next() // { value: "a", done: false }
it.next() // { value: "b", done: false }
it.next() // { value: undefined, done: true }

function makeIterator(array) { // 遍历器生成函数，作用就是返回一个遍历器对象
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex < array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true};
    }
  };
}
```

总结：调用遍历器生成函数返回一个遍历器对象，遍历器对象调用next()方法，进入下一个状态，并返回带有value和done属性的函数

### 4.2 默认 Iterator 接口

一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，**一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）**。

`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器对象。类似上面的makeIterator。

```js
const obj = {
  // 属性名Symbol.iterator，它是一个表达式，是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内
  [Symbol.iterator] : function () {
    return {
      next: function () {
        return {
          value: 1,
          done: true
        };
      }
    };
  }
};
```

总结：数据结构具有`Symbol.iterator`属性，该属性是遍历器生成函数，那么该数据结构就是可遍历，可以被for..of遍历

**原生具备 Iterator 接口的数据结构**

- Array
- Map
- Set
- String
- `TypedArray`
- 函数的 arguments 对象
- `NodeList` 对象

```js
let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator](); // 执行Symbol.iterator函数，得到遍历器对象

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
```

**对象**

`for...in`循环可以遍历键名，`for...of`循环会报错。

一个对象如果要具备可被`for...of`循环调用的 Iterator 接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。

```js
// 方法一：给对象增加Symbol.iterator属性
class RangeIterator {
  constructor(start, stop) {
    this.value = start;
    this.stop = stop;
  }
    
  [Symbol.iterator]() { return this; } // 返回当前对象
    
  next() {
    var value = this.value;
    if (value < this.stop) {
      this.value++;
      return {done: false, value: value};
    }
    return {done: true, value: undefined};
  }
}

function range(start, stop) {
  return new RangeIterator(start, stop);
}

for (var value of range(0, 3)) {
  console.log(value); // 0, 1, 2
}

// 方法二：使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组
for (var key of Object.keys(someObject)) {
  console.log(key + ': ' + someObject[key]);
}

// 方法三：使用 Generator 函数将对象重新包装一下
const obj = { a: 1, b: 2, c: 3 }
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}
for (let [key, value] of entries(obj)) {
  console.log(key, '->', value);
}
// a -> 1
// b -> 2
// c -> 3
```

**类似数组的对象**

对于类似数组的对象（存在数值键名和`length`属性），部署 Iterator 接口，有一个简便方法，就是`Symbol.iterator`方法直接引用数组的 Iterator 接口。

```js
// 普通对象部署数组的`Symbol.iterator`方法，并无效果，iterable没有数值键名
/*let iterable = {
    a: 'a',
    b: 'b',
    c: 'c',
    length: 3,
    [Symbol.iterator]: Array.prototype[Symbol.iterator]
};*/

let iterable = {
    0: 'a',
    1: 'b',
    2: 'c',
    length: 3,
    [Symbol.iterator]: Array.prototype[Symbol.iterator]
};
for (let item of iterable) {
    console.log(item); // 'a', 'b', 'c'
}

// 空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。
const arr = ['red', 'green', 'blue'];
const obj = {};
obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr); // 通过bind绑定了arr
for(let v of obj) { // for(let v of arr) {
  console.log(v); // red green blue
}

// 方法二：使用Array.from方法将其转为数组。
let arrayLike = { length: 2, 0: 'a', 1: 'b' };
for (let x of Array.from(arrayLike)) {
  console.log(x);
}
```

**调用 Iterator 接口的场合**

（1）**解构赋值**：对数组和 Set 结构进行解构赋值时，会默认调用`Symbol.iterator`方法。

（2）**扩展运算符**：只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。`let arr = [...iterable];`

（3）**yield***：后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口

```js
let generator = function* () {
  yield 1;
  yield* [2,3,4];
  yield 5;
};

var iterator = generator();

iterator.next() // { value: 1, done: false }
iterator.next() // { value: 2, done: false }
iterator.next() // { value: 3, done: false }
iterator.next() // { value: 4, done: false }
iterator.next() // { value: 5, done: false }
iterator.next() // { value: undefined, done: true }
```

（4）其他场合

- `for...of`
- `Array.from()`
- `Map()`, `Set()`, `WeakMap()`, `WeakSet()`（比如`new Map([['a',1],['b',2]])`）
- `Promise.all()`
- `Promise.race()`

```js
function* numbers () {
  yield 1
  yield 2
  return 3
  yield 4
}

// 下面场景会自动调用 Iterator 接口，对numbers进行遍历

// 扩展运算符
[...numbers()] // [1, 2] 只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组

// Array.from 方法
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers();
x // 1
y // 2

// for...of 循环
for (let n of numbers()) {
  console.log(n)
}
// 1
// 2
```

**字符串**

字符串是一个类似数组的对象，也原生具有 Iterator 接口。

```js
var str = new String("hi");

[...str] // ["h", "i"] 只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组

str[Symbol.iterator] = function() {
  return {
    next: function() {
      if (this._first) {
        this._first = false;
        return { value: "bye", done: false };
      } else {
        return { done: true };
      }
    },
    _first: true
  };
};

[...str] // ["bye"] 通过修改Symbol.iterator函数，修改遍历返回的内容
str // "hi"
```

**Iterator 接口与 Generator 函数**

`Symbol.iterator()`方法的最简单实现，几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。

```js
let myIterable = {
  [Symbol.iterator]: function* () {
    yield 1;
    yield 2;
    yield 3;
  }
};
[...myIterable] // [1, 2, 3]

// 或者采用下面的简洁写法

let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};

for (let x of obj) {
  console.log(x);
}
// "hello"
// "world"
```

总结：Generator 函数通过yield 给出每一步的返回值轻松实现`Symbol.iterator`

### 4.3 遍历器对象的 return()，throw()

遍历器对象除了具有`next()`方法，还可以具有`return()`方法和`throw()`方法。

- `return()`方法的使用场合是，如果`for...of`循环提前退出（通常是因为出错，或者有`break`语句），就会调用`return()`方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署`return()`方法。
- `throw()`方法主要是配合 Generator 函数使用

### 4.4 for...of 循环

`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法

```js
var $iterator = ITERABLE[Symbol.iterator]();
var $result = $iterator.next();
while (!$result.done) {
  var x = $result.value;
  // ...
  $result = $iterator.next();
}
```

**数组**

`for...in`循环，只能获得对象的**键名**，不能直接获取键值。ES6 提供`for...of`循环，允许遍历获得**键值**。

`for...in`循环主要是为遍历对象而设计的，不适用于遍历数组。

- 数组的键名是数字，但是`for...in`循环是以字符串作为键名“0”、“1”、“2”等等。
- `for...in`循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
- 某些情况下，`for...in`循环会以任意顺序遍历键名。

```js
let arr = [3, 5, 7];
arr.foo = 'hello';

for (let i in arr) {
  console.log(i); // "0", "1", "2", "foo"
}
// for...of循环不会返回数组arr的foo属性
for (let i of arr) {
  console.log(i); //  "3", "5", "7"
}

// for...of不同于forEach方法，它可以与break、continue和return配合使用
for (var n of fibonacci) {
  if (n > 1000)
    break;
  console.log(n);
}
```

**Set 和 Map 结构**

Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。

```js
var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);
for (var e of engines) {
  console.log(e);
} // Gecko Trident Webkit

let map = new Map().set('a', 1).set('b', 2);
for (let pair of map) {
  console.log(pair);
}
// ['a', 1]
// ['b', 2]
for (let [key, value] of map) {
  console.log(key + ' : ' + value);
}
// a : 1
// b : 2
```

**计算生成的数据结构**

- `entries()` 返回一个遍历器对象，用来遍历**`[键名, 键值]`组成的数组**。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用`entries`方法。
- `keys()` 返回一个遍历器对象，用来遍历所有的**键名**。
- `values()` 返回一个遍历器对象，用来遍历所有的**键值**。

```js
let arr = ['a', 'b', 'c'];
for (let pair of arr.entries()) {
  console.log(pair);
}
// [0, 'a']
// [1, 'b']
// [2, 'c']
```

**字符串**

会正确识别 32 位 UTF-16 字符

```js
for (let x of 'a\uD83D\uDC0A') {
  console.log(x);
}
// 'a'
// '\uD83D\uDC0A'
```

**通过遍历器实现“链表”结构**

```js
function Obj(value) {
    this.value = value;
    this.next = null;
}

Obj.prototype[Symbol.iterator] = function() { // 在对象上部署
    var iterator = { next: next };
    var current = this;
    function next() {
        if (current) {
            var value = current.value;
            current = current.next; // one {value: 1, next: two} next方法，用来移动指针，指向下一个对象
            return { done: false, value: value }; // 并返回一个对象，表示当前数据成员的信息
        }
        return { done: true };
    }
    return iterator; // 返回迭代器对象（包含next方法）
}

var one = new Obj(1);
var two = new Obj(2);
var three = new Obj(3);
one.next = two;
two.next = three;

for (var i of one){
    console.log(i); // 1, 2, 3
}
```

## 5、Generator 函数的语法

### 5.1 简介

语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。还是一个遍历器对象生成函数，执行 Generator 函数会返回一个遍历器对象。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

形式上，Generator 函数是一个普通函数，但是有两个特征。一是，`function`关键字与函数名之间有一个星号；二是，函数体内部使用`yield`表达式，定义不同的内部状态（`yield`在英语里的意思就是“产出”）。

```js
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

// 调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）
var hw = helloWorldGenerator();

// 调用遍历器对象的next方法，使得指针移向下一个状态，从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止
// 并返回一个对象，value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束
hw.next() // { value: 'hello', done: false }
hw.next() // { value: 'world', done: false }
hw.next() // { value: 'ending', done: true }
hw.next() // { value: undefined, done: true }
```

总结：调用Generator 函数生成遍历器对象，Generator 函数就是遍历器生成对象，调用对象的next方法，进入下一个状态，并返回具有value和done属性的对象。和迭代器的区别是，迭代器next指向**数据结构下一个数据并返回数据**，Generator 的next指**向函数运行状态，返回函数运行的值**。

**yield 表达式**

`yield`表达式只能用在 Generator 函数里面，用在其他地方都会报错。

遍历器对象的`next`方法的运行逻辑如下。

（1）遇到`yield`表达式，**就暂停执行后面的操作**，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。

（2）下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。

（3）如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。

（4）如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

正常函数只能返回一个值，因为只能执行一次`return`；Generator 函数可以返回一系列的值，因为可以有任意多个`yield`。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。

```JS
// yield表达式如果用在另一个表达式之中，必须放在圆括号里面
function* demo() {
  console.log('Hello' + yield); // SyntaxError
  console.log('Hello' + yield 123); // SyntaxError

  console.log('Hello' + (yield)); // OK
  console.log('Hello' + (yield 123)); // OK
}

// 作函数参数或放在赋值表达式的右边，可以不加括号
function* demo() {
  foo(yield 'a', yield 'b'); // OK
  let input = yield; // OK
}
```

总结：next返回yield后面的值，通过next可以传递参数作为yield后面的值。

**与 Iterator 接口的关系** 

任意一个对象的`Symbol.iterator`方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。

由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的`Symbol.iterator`属性，从而使得该对象具有 Iterator 接口。

```js
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
[...myIterable] // [1, 2, 3]

// gen是一个 Generator 函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。
function* gen(){
  // some code
}
var g = gen();
g[Symbol.iterator]() === g // true

// for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6; // 一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中
}
for (let v of foo()) {
  console.log(v);
} // 1 2 3 4 5
```

总结：`Symbol.iterator`可以通过Generator 实现

**作为对象属性的 Generator 函数**

```js
let obj = {
  * myGeneratorMethod() { // myGeneratorMethod: function* () {
    ···
  }
};
```

### 5.2 next 方法的参数

`yield`表达式本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。如果没有传递参数，上一个`yield`表达式就是undefined。

```js
// 可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为
function* f() {
  for(var i = 0; true; i++) {
    var reset = yield i;
    if(reset) { i = -1; }
  }
}

var g = f();

g.next() // { value: 0, done: false }
g.next() // { value: 1, done: false } 不断叠加
g.next(true) // { value: 0, done: false } 重置参数
```

第一次调用`next`方法时，就能够输入值，可以在 Generator 函数外面再包一层

```js
function wrapper(generatorFunction) {
    return function (...args) {
        let generatorObject = generatorFunction(...args);
        generatorObject.next();
        return generatorObject;
    };
}

const wrapped = wrapper(function* () {
    console.log(`First input: ${yield}`);
    return 'DONE';
});

wrapped().next('hello!')
// First input: hello!
```

### 5.3 throw() return()

**throw()** 

- Generator 函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。

- `throw`方法抛出的错误要被内部捕获，前提是必须至少执行过一次`next`方法。如果没有执行next就throw，错误直接在外部抛出。

- `throw`方法被捕获以后，会附带执行下一条`yield`表达式。也就是说，会附带执行一次`next`方法。

- 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用`next`方法，将返回一个`value`属性等于`undefined`、`done`属性等于`true`的对象，即 J**avaScript 引擎认为这个 Generator 已经运行结束了**。

```js
var g = function* () {
  try {
    yield;
  } catch (e) { // 内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获，内外都没有部署程序就会报错
    console.log('内部捕获', e);
  }
};

var i = g();
i.next();

try {
  throw new Error('a'); // 只能被函数体外的catch语句捕获
  i.throw('a');
  i.throw('b'); // i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获
} catch (e) {
  console.log('外部捕获', e);
}
// 内部捕获 a
// 外部捕获 b

// 遍历器的throw方法抛出的错误，不影响下一次遍历
var gen = function* gen(){
  try {
    yield console.log('a');
  } catch (e) {
    // ...
  }
  yield console.log('b');
  yield console.log('c');
}
var g = gen();
g.next() // a
g.throw() // b 附带执行一次next方法
g.next() // c
```

**return()**

可以返回给定的值，并且终结遍历 Generator 函数

不提供参数，则返回值的`value`属性为`undefined`

如果 Generator 函数内部有`try...finally`代码块，且正在执行`try`代码块，那么`return()`方法会导致立刻进入`finally`代码块，执行完以后，整个函数才会结束。

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next() // { value: 1, done: false }
g.return('foo') // { value: "foo", done: true }
g.next() // { value: undefined, done: true } 再调用next()方法，done属性总是返回true

// finally
function* numbers () {
  yield 1;
  try {
    yield 2;
    yield 3;
  } finally {
    yield 4;
    yield 5;
  }
  yield 6;
}
var g = numbers();
g.next() // { value: 1, done: false }
g.next() // { value: 2, done: false }
g.return(7) // { value: 4, done: false }
g.next() // { value: 5, done: false }
g.next() // { value: 7, done: true }
```

**next()、throw()、return() 的共同点**

让 Generator 函数恢复执行，并且使用不同的语句替换`yield`表达式

- `next()`是将`yield`表达式替换成一个值

- `throw()`是将`yield`表达式替换成一个`throw`语句

- `return()`是将`yield`表达式替换成一个`return`语句

```js
const g = function* (x, y) {
  let result = yield x + y;
  return result;
};
const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false}

// 相当于将 let result = yield x + y替换成 let result = 1;
gen.next(1); // Object {value: 1, done: true}

// 相当于将 let result...替换成 let result = throw(new Error('出错了'));
gen.throw(new Error('出错了')); // Uncaught Error: 出错了

// 相当于将 let result...替换成 let result = return 2;
gen.return(2); // Object {value: 2, done: true}
```

### 5.4 yield* 表达式

用来在一个 Generator 函数里面执行另一个 Generator 函数

```js
function* foo() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yield 'x';
  yield* foo();
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

// 等同于 
function* bar() {
  yield 'x';
  for (let v of foo()) {
    yield v;
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
} // "x" "a" "b" "y"
```

`yield*`后面的 Generator 函数（没有`return`语句时），等同于在 Generator 函数内部，部署一个`for...of`循环

```js
function* foo() {
  yield 2;
  yield 3;
  return "foo";
}

function* bar() {
  yield 1;
  var v = yield* foo(); // 获取`return`语句的值
  console.log("v: " + v);
  yield 4;
}

var it = bar();

it.next() // {value: 1, done: false}
it.next() // {value: 2, done: false}
it.next() // {value: 3, done: false}
it.next() // {value: 4, done: false}  "v: foo"    
it.next() // {value: undefined, done: true}
```

如果`yield*`后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。实际上，任何数据结构只要有 Iterator 接口，就可以被`yield*`遍历。

```js
// 第一次是扩展运算符遍历函数logReturned返回的遍历器对象
// 第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象
function* genFuncWithReturn() {
  yield 'a';
  yield 'b';
  return 'The result';
}
function* logReturned(genObj) {
  let result = yield* genObj;
  console.log(result);
}

[...logReturned(genFuncWithReturn())]
// The result
// 值为 [ 'a', 'b' ]
```

**扁平化**

`yield*`命令可以很方便地取出嵌套数组的所有成员

```js
const tree = [ 'a', ['b', ['c']], ['d', 'e'] ];
function* iterTree(tree) {
    if (Array.isArray(tree)) {
        for(let i=0; i < tree.length; i++) {
            yield* iterTree(tree[i]);
        }
    } else {
        yield tree;
    }
}
// 扩展运算符...默认调用 Iterator 接口
const hello = [...iterTree(tree)] // ["a", "b", "c", "d", "e"]
```

**遍历完全二叉树**

```js
// 下面是二叉树的构造函数，三个参数分别是左树、当前节点和右树
function Tree(left, label, right) {
    this.left = left;
    this.label = label;
    this.right = right;
}

// 下面生成二叉树
function make(array) {
    // 判断是否为叶节点
    if (array.length == 1) return new Tree(null, array[0], null);
    return new Tree(make(array[0]), array[1], make(array[2]));
}
let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);  
//       d
//   b       f
// a   c    e  g

// 下面是中序（inorder）遍历函数。
// 由于返回的是一个遍历器，所以要用generator函数。函数体内采用递归算法，所以左树和右树要用yield*遍历
function* inorder(t) {
    if (t) {
        yield* inorder(t.left);
        yield t.label;
        yield* inorder(t.right);
    }
}

// 遍历二叉树
var result = [];
for (let node of inorder(tree)) {
    result.push(node);
}

result // ['a', 'b', 'c', 'd', 'e', 'f', 'g']
```

### 5.5 Generator 函数的this



### 5.6 应用



## 6、Generator 函数的异步应用

传统方法



基本概念



Generator 函数



Thunk 函数



co 模块



## 7、async 函数

含义

基本用法

语法

async 函数的实现原理

与其他异步处理方法的比较

实例：按顺序完成异步操作

顶层 await

## 8、异步遍历器

同步遍历器的问题

异步遍历的接口

for await...of

异步 Generator 函数

yield* 语句



