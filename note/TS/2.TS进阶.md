## 1、函数

### 1.1 简介

如果变量被赋值为一个函数，变量的类型有两种写法。

```ts
// 写法一
const hello = function (txt:string) {
  console.log('hello ' + txt);
}

// 写法二
const hello:
  (txt:string) => void
= function (txt) {
  console.log('hello ' + txt);
};

// 往往用type命令为函数类型定义一个别名，便于指定给其他变量。
type MyFunc = (txt:string) => void;
const hello:MyFunc = function (txt) {
  console.log('hello ' + txt);
};

// TypeScript 允许省略参数
let myFunc: (a:number, b:number) => number;
myFunc = (a:number) => a; // 正确
myFunc = (a:number, b:number, c:number) => a + b + c; // 报错
```

**Function 类型**

TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型。

Function 类型的函数可以接受任意数量的参数，每个参数的类型都是`any`，返回值的类型也是`any`，代表没有任何约束，所以不建议使用这个类型，给出函数详细的类型声明会更好。

### 1.2 参数

**A 可选参数**

参数名带有问号，表示该参数的类型实际上是`原始类型|undefined`，它有可能为`undefined`。

```ts
// 参数的类型实际上是原始类型|undefined
function f(x?:number) {
  // ...
}

f(); // OK
f(10); // OK
```

函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。

如果前部参数有可能为空，这时只能显式注明该参数类型可能为`undefined`。

函数体内部用到可选参数时，需要判断该参数是否为`undefined`。

```ts
let myFunc: (a:number, b?:number) => number; 
myFunc = function (x, y) {
  if (y === undefined) {
    return x;
  }
  return x + y;
}
```

**B 参数默认值**

可选参数与默认值不能同时使用。

设置了默认值的参数，就是可选的。如果不传入该参数，它就会等于默认值。

设有默认值的参数，如果传入`undefined`，也会触发默认值。

```ts
function add(x:number = 0, y:number) {
  return x + y;
}

add(1) // 报错
add(undefined, 1) // 正确
```

**C 参数解构**

```ts
function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}

// 参数解构可以结合类型别名（type 命令）一起使用，代码会看起来简洁一些。
type ABC = { a:number; b:number; c:number };
function sum({ a, b, c }:ABC) {
  console.log(a + b + c);
}
```

**D rest 参数**

rest 参数表示函数剩余的所有参数，它可以是数组（剩余参数类型相同），也可能是元组（剩余参数类型不同）。

```ts
// rest 参数为数组
function joinNumbers(...nums:number[]) {
  // ...
}

// rest 参数为元组
function f(...args:[boolean, number]) {
  // ...
}

// rest 参数甚至可以嵌套。
function f(...args:[boolean, ...string[]]) {
  // ...
}
```

**E `readonly` 只读参数**

如果函数内部不能修改某个参数，可以在函数定义时，在参数类型前面加上`readonly`关键字，表示这是只读参数。

```ts
function arraySum(
  arr:readonly number[]
) {
  // ...
  arr[0] = 0; // 报错
}
```

### 1.3 返回类型

**A void 类型**

void 类型允许返回`undefined`或`null`。函数的运行结果如果是抛出错误，也允许将返回值写成`void`。

如果打开了`strictNullChecks`编译选项，那么 void 类型只允许返回`undefined`。

**B never 类型**

`never`类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。

- `never`类型表示函数**没有执行结束**，不可能有返回值；
- `void`类型表示函数正常执行结束，但是**不返回值**，或者说返回`undefined`。

```ts
//（1）抛出错误的函数。
function fail(msg:string):never {
  throw new Error(msg);
}

// （2）无限执行的函数。
const sing = function():never {
  while (true) {
    console.log('sing');
  }
};
```

一个函数如果某些条件下有正常返回值，另一些条件下抛出错误，这时它的返回值类型可以省略`never`。

`never`是 TypeScript 的唯一一个底层类型，所有其他类型都包括了`never`。从集合论的角度看，`number|never`等同于`number`。

```ts
function sometimesThrow():number {
  if (Math.random() > 0.5) {
    return 100;
  }

  throw new Error('Something went wrong');
}

const result = sometimesThrow();
```

### 1.4 其他函数

**A 高阶函数**

一个函数（高阶函数）的返回值还是一个函数，那么前一个函数就称为高阶函数（higher-order function）。

```ts
(someValue: number) => (multiplier: number) => someValue * multiplier;
```

**B 函数重载**

有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。

TypeScript 对于“函数重载”的类型声明方法是，逐一定义每一种情况的类型。

TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。

```ts
function reverse(str:string):string;
function reverse(arr:any[]):any[];
function reverse(
  stringOrArray:string|any[]
):string|any[] {
  if (typeof stringOrArray === 'string')
    return stringOrArray.split('').reverse().join('');
  else
    return stringOrArray.slice().reverse();
}

// 对象的方法也可以使用重载。

class StringBuilder {
  #data = '';
  add(num:number): this;
  add(bool:boolean): this;
  add(str:string): this;
  add(value:any): this {
    this.#data += String(value);
    return this;
  }
  toString() {
    return this.#data;
  }
}
```

由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用联合类型替代函数重载，除非多个参数之间、或者某个参数与返回值之间，存在对应关系。

```ts
// 写法一
function len(s:string):number;
function len(arr:any[]):number;
function len(x:any):number {
  return x.length;
}

// 写法二
function len(x:any[]|string):number {
  return x.length;
}
```

**C 构造函数**

构造函数的类型写法，就是在参数列表前面加上new命令。

```ts
class Animal {
  numLegs:number = 4;
}
type AnimalConstructor = new () => Animal;
function create(c:AnimalConstructor):Animal {
  return new c();
}
const a = create(Animal);

// 构造函数还有另一种类型写法，就是采用对象形式。
type F = {
  new (s:string): object;
};

// 某些函数既是构造函数，又可以当作普通函数使用，比如Date()
type F = {
  new (s:string): object;
  (n?:number): number;
}
```

## 2、对象

### 2.1 简介

除了`type`命令可以为对象类型声明一个别名，TypeScript 还提供了`interface`命令，可以把对象类型提炼为一个接口。

一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。不能删除类型声明中存在的属性，修改属性值是可以的。

不区分对象自身的属性和继承的属性，一律视为对象的属性。

```ts
// 写法一
type MyObj = {
  x:number;
  y:number;
  toString(): string; // 继承的属性
};
const obj:MyObj = { x: 1, y: 1 };

// 写法二
interface MyObj {
  x: number;
  y: number;
}
const obj:MyObj = { x: 1, y: 1 };
```

### 2.2 对象属性

**A 可选属性**

可选属性等同于允许赋值为`undefined`，下面两种写法是等效的。

```TS
type User = {
  firstName: string;
  lastName?: string;
};

// 等同于
type User = {
  firstName: string;
  lastName?: string|undefined;
};
```

读取可选属性之前，必须检查一下是否为`undefined`。

只要同时打开`ExactOptionalPropertyTypes`和`strictNullChecks`，可选属性就不能设为`undefined`。

```ts
// 写法一
let firstName = (user.firstName === undefined) ? 'Foo' : user.firstName;
let lastName = (user.lastName === undefined) ? 'Bar' : user.lastName;

// 写法二
let firstName = user.firstName ?? 'Foo';
let lastName = user.lastName ?? 'Bar';
```

**B 只读属性**

只读属性只能在对象初始化期间赋值，此后就不能修改该属性。

如果属性值是一个对象，`readonly`修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。

```ts
type Point = {
  readonly x: number;
  readonly y: number;
};

const p:Point = { x: 0, y: 0 };
p.x = 100; // 报错
```

如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。

```ts
interface Person {
  name: string;
  age: number;
}
interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}

let w:Person = {
  name: 'Vicky',
  age: 42,
};
let r:ReadonlyPerson = w;

w.age += 1;
r.age // 43
```

如果希望属性值是只读的，除了声明时加上`readonly`关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言`as const`。

```ts
const myUser = {
  name: "Sabrina",
} as const;
myUser.name = "Cynthia"; // 报错

// 变量myUser的类型声明，name不是只读属性，但是赋值时又使用只读断言as const。这时会以声明的类型为准，因为name属性可以修改。
const myUser:{ name: string } = {
  name: "Sabrina",
} as const;
myUser.name = "Cynthia"; // 正确
```

**C 属性名的索引类型**

`TypeScript` 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。

索引类型里面，最常见的就是属性名的字符串索引。

属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。

```ts
// 声明type
type MyObj = {
  [property: string]: string
};
// 其他JS对象
type T1 = {
  [property: number]: string
};
type T2 = {
  [property: symbol]: string
};

const obj:MyObj = {
  foo: 'a',
  bar: 'b',
  baz: 'c',
};
```

数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。

类型MyType同时有两种属性名索引，但是数值索引与字符串索引冲突了，所以报错了。由于字符属性名的值类型是string，数值属性名的值类型只有同样为string，才不会报错。

```ts
type MyType = {
  [x: number]: boolean; // 报错
  [x: string]: string;
}
```

可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名不符合属性名索引的范围，两者发生冲突，就会报错。

```ts
type MyType = {
  foo: string;
  [x: string]: string;
}

// 属性名foo符合属性名的字符串索引，但是两者的属性值类型不一样，所以报错了。
type MyType = {
  foo: boolean; // 报错
  [x: string]: string;
}
```

**D 解构赋值**

解构赋值的类型写法，跟为对象声明类型是一样的。

```ts
const {id, name, price}:{
  id: string;
  name: string;
  price: number
} = product;
```

**E 结构类型原则**

只要对象 B 满足 对象 A 的结构特征，`TypeScript` 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）。

如果类型 B 可以赋值给类型 A，`TypeScript` 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。

```ts
type myObj = { x: number, y: number, };

function getSum(obj:myObj) {
  let sum = 0;
  for (const n of Object.keys(obj)) {
    // obj[n]取出的属性值不一定是数值（number），使得变量v的类型被推断为any
    const v = obj[n]; // 报错
    sum += Math.abs(v);
  }
  return sum;
}

function getSum(obj:MyObj) {
  // 函数体内部只使用了属性x和y，这两个属性有明确的类型声明，保证obj.x和obj.y肯定是数值
  return Math.abs(obj.x) + Math.abs(obj.y);
}
```

**F 严格字面量检查**

如果对象使用字面量表示，会触发 `TypeScript` 的严格字面量检查（strict object literal checking）。

如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。

```ts
const point:{  x:number; } = {
  x: 1,
  z: 1 // 报错
};

const myPoint = { x: 1, z: 1 };
const point:{ x:number; } = myPoint; // 正确
```

由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。

编译器选项`suppressExcessPropertyErrors`，可以关闭多余属性检查。

```TS
interface Point {
  x: number;
  y: number;
}
function computeDistance(point: Point) { /*...*/ }

computeDistance({ x: 1, y: 2, z: 3 }); // 报错
computeDistance({x: 1, y: 2}); // 正确
```

**E 最小可选属性规则**

如果某个类型的所有属性都是可选的，那么该类型的对象必须至少存在一个可选属性，不能所有可选属性都不存在。这就叫做“最小可选属性规则”。

如果想规避这条规则，要么在类型里面增加一条索引属性（`[propName: string]: someType`），要么使用类型断言（`opts as Options`）。

```ts
type Options = {
  a?:number;
  b?:number;
  c?:number;
};

const opts = { d: 123 };
const obj:Options = opts; // 报错
```

### 2.3 空对象

变量`obj`的值是一个空对象，然后对`obj.prop`赋值就会报错。

空对象只能使用继承的属性，即继承自原型对象`Object.prototype`的属性。

```ts
const obj = {};
obj.prop = 123; // 报错
obj.toString() // 正确
```

需要分步声明，一个比较好的方法是，使用扩展运算符（`...`）合成一个新对象。

```ts
const pt0 = {};
const pt1 = { x: 3 };
const pt2 = { y: 4 };

const pt = {
  ...pt0, ...pt1, ...pt2
};
```

空对象作为类型，其实是`Object`类型的简写形式。各种类型的值（除了`null`和`undefined`）都可以赋值给空对象类型，跟`Object`类型的行为是一样的。

因为`Object`可以接受各种类型的值，而空对象是`Object`类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性。

```ts
let d:{}; // 等同于 let d:Object;
d = {};
d = 2;
d = { x: 1 };

b.x // 报错
```

如果想强制使用没有任何属性的对象，可以采用下面的写法。

```ts
interface WithoutProperties {
  [key: string]: never;
}

// 报错
const a:WithoutProperties = { prop: 1 };
```

## 3、interface 接口

### 3.1 简介

interface 可以表示对象的各种语法，它的成员有5种形式。

- 对象属性
- 对象的属性索引

```ts
// 对象属性
interface Point {
  x: number;
  y: number;
}

// 对象的属性索引
interface A {
  [prop: number]: string;
}
```

- 对象方法

```ts
// 写法一
interface A {
  f(x: boolean): string;
}

// 写法二
interface B {
  f: (x: boolean) => string;
}

// 写法三
interface C {
  f: { (x: boolean): string };
}

// 属性名可以采用表达式，所以下面的写法也是可以的。
const f = 'f';
interface A {
  [f](x: boolean): string;
}
```

- 函数
- 构造函数：TypeScript 里面，构造函数特指具有`constructor`属性的类

```ts
// 函数
interface Add {
  (x:number, y:number): number;
}
const myAdd:Add = (x,y) => x + y;


// 构造函数 使用new关键字
interface ErrorConstructor {
  new (message?: string): Error;
}
```

### 3.2 interface 的继承

**A interface 继承 interface**

interface 可以使用`extends`关键字，继承其他 interface。

如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。

多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。

```TS
interface Style {
  color: string;
}

interface Shape {
  name: string;
}

interface Circle extends Style, Shape {
  radius: number;
}
```

**B interface 继承 type**

如果`type`命令定义的类型不是对象，interface 就无法继承。

```TS
type Country = {
  name: string;
  capital: string;
}

interface CountryWithPop extends Country {
  population: number;
}
```

**C interface 继承 class**

某些类拥有私有成员和保护成员，interface 可以继承这样的类，但是意义不大。

```TS
class A {
  private x: string = '';
  protected y: string = '';
}

interface B extends A {
  z: number
}

// 报错
const b:B = { /* ... */ }

// 报错
class C implements B {
  // ...
}
```

### 3.3 接口合并

多个同名接口会合并成一个接口。两个`Box`接口会合并成一个接口，同时有`height`、`width`和`length`三个属性。

同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。

```TS
interface Box {
  height: number;
  width: number;
}

interface Box {
  length: number;
}
```

同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。

```TS
interface Cloner {
  clone(animal: Animal): Animal;
}

interface Cloner {
  clone(animal: Sheep): Sheep;
}

// 等同于
interface Cloner {
  clone(animal: Dog): Dog;
  clone(animal: Cat): Cat;
}
```

例外：同名方法之中，如果有一个参数是字面量类型，字面量类型有更高的优先级。

```ts
interface A {
  f(x:'foo'): boolean;
}

interface A {
  f(x:any): void;
}

// 等同于
interface A {
  f(x:'foo'): boolean;
  f(x:any): void;
}
```

如果两个 interface 组成的联合类型存在同名属性，那么该属性的类型也是联合类型。

```ts
interface Circle {
  area: bigint;
}
interface Rectangle {
  area: number;
}

declare const s: Circle | Rectangle;
s.area;   // bigint | number
```

### 3.4 interface 与 type 的异同

几乎所有的 interface 命令都可以改写为 type 命令。

`class`命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用`type`或`interface`。

interface 与 type 的区别有下面几点。

（1）`type`能够表示非对象类型，而`interface`只能表示对象类型（包括数组、函数等）。

（2）`interface`可以继承其他类型，`type`不支持继承。`type`定义的对象类型如果想要添加属性，只能使用`&`运算符，重新定义一个类型。

（3）同名`interface`会自动合并（枚举也可以合并），同名`type`则会报错。

（4）`interface`不能包含属性映射（mapping），`type`可以。

（5）`this`关键字只能用于`interface`。

（6）`type` 可以扩展原始数据类型，`interface` 不行。

（7）`interface`无法表达某些复杂类型（比如交叉类型和联合类型），但是`type`可以。

```ts
// interface 可以继承 type。
type Foo = { x: number; };
interface Bar extends Foo {
  y: number;
}

// type 也可以继承 interface。
interface Foo {
  x: number;
}
type Bar = Foo & { y: number; };

// 属性映射
interface Point {
  x: number;
  y: number;
}
// 正确
type PointCopy1 = {
  [Key in keyof Point]: Point[Key];
};
// 报错
interface PointCopy2 {
  [Key in keyof Point]: Point[Key];
};

// this
// 正确
interface Foo {
  add(num:number): this;
};
// 报错
type Foo = {
  add(num:number): this;
};

// 扩展原始数据类型
// 正确
type MyStr = string & {
  type: 'new'
};
// 报错
interface MyStr extends string {
  type: 'new'
}

// 复杂类型
type A = { /* ... */ };
type B = { /* ... */ };

type AorB = A | B;
type AorBwithName = AorB & {
  name: string
}
```

## 4、class

### 4.1 简介

**A 属性的类型**

类的属性可以在顶层声明，也可以在构造方法内部声明。

`TypeScript` 有一个配置项`strictPropertyInitialization`，只要打开（默认是打开的），就会检查属性是否设置了初值，如果没有就报错。

```TS
// 打开 strictPropertyInitialization
class Point {
  x: number; // 报错
  y: number; // 报错
}
// 如果不希望出现报错，可以使用非空断言。
class Point {
  x!: number;
  y!: number;
}
```

**B `readonly` 修饰符**

属性名前面加上 `readonly` 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。

`readonly` 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。如果两个地方都设置了只读属性的值，以构造方法为准。

```TS
class A {
  readonly id = 'foo';
  constructor() {
    this.id = 'bar'; // 正确
  }
}

const a = new A();
a.id = 'bar'; // 报错
```

**C 方法的类型**

构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象

```TS
class Point {
  x: number;
  y: number;

  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  add(point:Point) {
    return new Point(
      this.x + point.x,
      this.y + point.y
    );
  }
}
```

**D 存取器方法**

（1）如果某个属性只有`get`方法，没有`set`方法，那么该属性自动成为只读属性。

（2）`TypeScript` 5.1 版之前，`set`方法的参数类型，必须兼容`get`方法的返回值类型，否则报错。

（3）`get`方法与`set`方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。

```TS
class C {
  _name = '';
  get name():string {
    return this._name;
  }
  set name(value:number|string) {
    this._name = String(value);
  }
}
```

**E 属性索引**

由于类的方法是一种特殊属性（属性值为函数的属性），所以属性索引的类型定义也涵盖了方法。如果一个对象同时定义了属性索引和方法，那么前者必须包含后者的类型。

属性存取器视同属性。

```TS
class MyClass {
  [s:string]: boolean;
  f() { // 报错
    return true;
  }
  get isInstance() {
    return true;
  }
}

class MyClass {
  [s:string]: boolean | ((s:string) => boolean);

  get(s:string) {
    return this[s] as boolean;
  }
}
```

### 4.2 类的 interface 接口

**A implements 关键字**

类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。

`implements`关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。

interface 描述的是类的对外接口，也就是实例的公开属性和公开方法，不能定义私有的属性和方法。

```ts
class Car {
  id:number = 1;
  move():void {};
}

class MyCar implements Car {
  id = 2; // 不可省略
  move():void {};   // 不可省略
}
```

**B 实现多个接口**

```ts
// SecretCar类继承了Car类，然后再实现Flyable和Swimmable两个接口
class Car implements MotorVehicle {
}

class SecretCar extends Car implements Flyable, Swimmable {
}
```

**C 类与接口的合并**

`TypeScript `不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。

合并进类的非空属性（上例的`y`），如果在赋值之前读取，会返回`undefined`。

```ts
class A {
  x:number = 1;
}

interface A {
  y:number;
}

let a = new A();
a.y // undefined
```

### 4.3 Class 类型

**A 实例类型**

类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。

对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。

```ts
interface MotorVehicle {
}

class Car implements MotorVehicle {
}

// 写法一
const c1:Car = new Car();
// 写法二
const c2:MotorVehicle = new Car();
```

**B 类的自身类型**

要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。

```ts
interface PointConstructor {
  new(x:number, y:number):Point;
}

function createPoint(
  // PointClass:Point, // Point描述的是实例类型，而不是 Class 的自身类型
  PointClass:typeof Point,
  PointClass: new (x:number, y:number) => Point, // 类只是构造函数的一种语法糖，本质上是构造函数的另一种写法
  PointClass: PointConstructor, // 构造函数也可以写成对象形式
  x:number,
  y:number
):Point {
  return new PointClass(x, y);
}
```

**C 结构类型原则**

如果两个类的实例结构相同，那么这两个类就是兼容的，可以用在对方的使用场合。

一个对象只要满足 Class 的实例结构，就跟该 Class 属于同一个类型。

确定两个类的兼容关系时，只检查实例成员，不考虑静态成员和构造方法。

如果类中存在私有成员（private）或保护成员（protected），那么确定兼容关系时，TypeScript 要求私有成员和保护成员来自同一个类，这意味着两个类需要存在继承关系。

```ts
class Person {
  name: string;
  age: number;
    
}

class Customer {
  name: string;
  static t: number;
  constructor(x:number) {}
}

// 正确
const cust:Customer = new Person();
```

### 4.4 类的继承

类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。

根据结构类型原则，子类也可以用于类型为基类的场合。

子类可以覆盖基类的同名方法。但是，子类的同名方法不能与基类的类型定义相冲突。

```ts
class A {
  greet() {
    console.log('Hello, world!');
  }
}

class B extends A {
  // 报错
  greet(name?:string) {
    console.log(`Hello, ${name}`);
  }
}
```

如果基类包括保护成员（`protected`修饰符），子类可以将该成员的可访问性设置为公开（`public`修饰符），也可以保持保护成员不变，但是不能改用私有成员（`private`修饰符）。

```ts
class A {
  protected x: string = '';
  protected y: string = '';
  protected z: string = '';
}

class B extends A {
  public x:string = ''; // 正确
  protected y:string = ''; // 正确
  private z: string = ''; // 报错
}
```

`extends`关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。

```ts
class MyArray extends Array<number> {}
class MyError extends Error {}
```

### 4.5 可访问性修饰符

**A public**

`public`修饰符表示这是**公开**成员，外部可以自由访问。

`public`修饰符是默认修饰符，如果省略不写，实际上就带有该修饰符。

```ts
class Greeter {
  public greet() {
    console.log("hi!");
  }
}

const g = new Greeter();
g.greet();
```

**B private**

`private`修饰符表示私有成员，只能用在当前**类的内部**，类的实例和子类都不能使用该成员。

子类不能定义父类私有成员的同名成员。

```ts
class A {
  private x = 0;
}

class B extends A {
  x = 1; // 报错
}
```

ES2022 引入了自己的私有成员写法`#propName`。建议不使用`private`，改用 ES2022 的写法，获得真正意义的私有成员。

```ts
class A {
  private x = 1;
  #y = 1;
}

const a = new A();
a['x'] // 1
a['y'] // 报错
```

构造方法也可以是私有的，这就直接防止了使用`new`命令生成实例对象，只能在类的内部创建实例对象。

这时一般会有一个静态方法，充当工厂函数，强制所有实例都通过该方法生成。

```ts
class Singleton {
  private static instance?: Singleton;
  private constructor() {}
  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}

const s = Singleton.getInstance();
```

**C protected**

`protected`修饰符表示该成员是保护成员，只能在**类的内部**使用该成员，实例无法使用该成员，但是**子类内部**可以使用。

子类不仅可以拿到父类的保护成员，还可以定义同名成员。

```ts
class A {
  protected x = 1;
  f(obj:A) {
    console.log(obj.x);
  }
}

const a = new A();
a.x // 报错
a.f(a) // 1
```

**D 实例属性的简写形式**

实际开发中，很多实例属性的值，是通过构造方法传入的。

构造方法的参数名只要有`public`、`private`、`protected`、`readonly`修饰符，都会自动声明对应修饰符的实例属性。

```ts
class Point {
  x:number;
  y:number;
  constructor(x:number, y:number) {
    this.x = x;
    this.y = y;
  }
}

// 简写形式
class Point {
  constructor(
    public readonly x:number,
    public y:number
  ) {}
}
```

**E 静态成员**

类的内部可以使用`static`关键字，定义静态成员。

静态成员是只能通过类本身使用的成员，不能通过实例对象使用。

`static`关键字前面可以使用 public、private、protected 修饰符。

`public`和`protected`的静态成员可以被继承。

```TS
class A {
  public static x = 1;
  protected static y = 1;
}

class B extends A {
  static getY() {
    return B.y;
  }
}

B.x // 1
B.getY() // 1
```

**F 泛型类**

类也可以写成泛型，使用类型参数。

注意，静态成员不能使用泛型的类型参数。

```ts
class Box<Type> {
  contents: Type;
  constructor(value:Type) {
    this.contents = value;
  }
}

const b:Box<string> = new Box('hello!');
```

**G 抽象类，抽象成员**

`TypeScript` 允许在类的定义前面，加上关键字`abstract`，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abstract class）。

抽象类只能当作基类使用，用来在它的基础上定义子类。

抽象类的子类也可以是抽象类，也就是说，抽象类可以继承其他抽象类。

抽象类的内部可以有已经实现好的属性和方法，也可以有还未实现的属性和方法(抽象成员)。如果子类没有实现抽象成员，就会报错。

```TS
abstract class A {
  abstract foo:string;
  bar:string = '';
}

class B extends A {
  foo = 'b';
}
```

注意点。

（1）抽象成员只能存在于抽象类，不能存在于普通类。

（2）抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加`abstract`关键字。

（3）抽象成员前也不能有`private`修饰符，否则无法在子类中实现该成员。

（4）一个子类最多只能继承一个抽象类。

**H this 问题**

```TS
class A {
  name = 'A';

  getName() {
    return this.name;
  }
}
const a = new A();
a.getName() // 'A'

const b = {
  name: 'b',
  getName: a.getName
};
b.getName() // 'b'
```

`TypeScript` 允许函数增加一个名为`this`的参数，放在参数列表的第一位，用来描述函数内部的`this`关键字的类型。

编译时，TypeScript 一旦发现函数的第一个参数名为`this`，则会去除这个参数，即编译结果不会带有该参数。

```ts
class A {
  name = 'A';
  getName(this: A) {
    return this.name;
  }
}

const a = new A();
const b = a.getName;
b() // 报错
```

`TypeScript` 提供了一个`noImplicitThis`编译选项。如果打开了这个设置项，如果`this`的值推断为`any`类型，就会报错。

在类的内部，`this`本身也可以当作类型使用，表示当前类的实例对象。

```ts
class Box {
  contents:string = '';
  set(value:string):this {
    this.contents = value;
    return this;
  }
}
```

`this`类型不允许应用于静态成员。`this`类型表示实例对象，但是静态成员拿不到实例对象。

有些方法返回一个布尔值，表示当前的`this`是否属于某种类型。这时，这些方法的返回值类型可以写成`this is Type`的形式，其中用到了`is`运算符。

```ts
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }
  isDirectory(): this is Directory {
    return this instanceof Directory;
  }
}
```

## 5、泛型

泛型本质上是一个类型函数，通过输入参数，获得结果，两者是一一对应关系。

### 5.1 简介

函数`getFirst()`的参数类型是`T[]`，返回值类型是`T`，就清楚地表示了两者之间的关系。

一般会使用`T`（type 的第一个字母）作为类型参数的名字。如果有多个类型参数，则使用 T 后面的 U、V 等字母命名，各个参数之间使用逗号（“,”）分隔。

```TS
function getFirst<T>(arr:T[]):T {
  return arr[0];
}

// 函数调用时，需要提供类型参数
getFirst<number>([1, 2, 3])

// 为了方便，函数调用时，往往省略不写类型参数的值，让 TypeScript 自己推断
getFirst([1, 2, 3])
```

### 5.2 泛型的写法

**A 函数的泛型写法**

变量形式定义的函数，泛型有下面两种写法。

```TS
function id<T>(arg:T):T {
  return arg;
}

// 写法一
let myId:<T>(arg:T) => T = id;

// 写法二
let myId:{ <T>(arg:T): T } = id;
```

**B 接口的泛型写法**

```ts
// 类型参数定义在整个接口，接口内部的所有属性和方法都可以使用该类型参数
interface Comparator<T> {
  compareTo(value:T): number;
}
class Rectangle implements Comparator<Rectangle> {
  compareTo(value:Rectangle): number {ruan
  }
}

// 类型参数定义在某个方法之中，其他属性和方法不能使用该类型参数
interface Fn {
  <Type>(arg:Type): Type;
}
function id<Type>(arg:Type): Type {
  return arg;
}
let myId:Fn = id;
```

**C 类的泛型写法**
泛型类描述的是类的实例，不包括静态属性和静态方法。
```ts
const Container = class<T> {
  constructor(private readonly data:T) {}
};
// 新建实例时，需要同时给出类型参数T和类参数data的值
const a = new Container<boolean>(true);
const b = new Container<number>(0);
```
`JavaScript` 的类本质上是一个构造函数，因此也可以把泛型类写成构造函数。
```ts
type MyClass<T> = new (...args: any[]) => T;
// 或者
interface MyClass<T> {
  new(...args: any[]): T;
}

// 用法实例
function createInstance<T>(
  AnyClass: MyClass<T>,
  ...args: any[]
):T {
  return new AnyClass(...args);
}
```
**D 类型别名`type`的泛型写法**
```ts
type Container<T> = { value: T };
const a: Container<number> = { value: 0 };
const b: Container<string> = { value: 'b' };

// 定义树形结构
type Tree<T> = {
  value: T;
  left: Tree<T> | null;
  right: Tree<T> | null;
};
```
**E 数组的泛型表示**
数组类型的写法`number[]`、`string[]`，只是`Array<number>`、`Array<string>`的简写形式。`ReadonlyArray<T>`接口，表示只读数组。
`Map`、`Set` 和 `Promise` 也是泛型接口，完整的写法是 `Map<K, V>`、`Set<T>` 和 `Promise<T>`。
```ts
interface Array<Type> {
  length: number;
  pop(): Type|undefined;
  push(...items:Type[]): number;
  // ...
}
```
### 5.3 类型参数扩展
**A 默认值**
如果没有给出类型参数的值，就会使用默认值。
`TypeScript` 会从实际参数推断出 `T` 的值，从而覆盖掉默认值。
类型参数的默认值，往往用在类中。
一旦类型参数有默认值，就表示它是可选参数。如果有多个类型参数，可选参数必须在必选参数之后。
```ts
class Generic<T = string> {
  list:T[] = []
  add(t:T) {
    this.list.push(t)
  }
}

const g = new Generic();
g.add(4) // 报错
g.add('hello') // 正确
```
**B 约束条件**
类型参数的约束条件形式：`<TypeParameter extends ConstraintType>`。
`TypeParameter` 表示类型参数， `extends` 是关键字，`ConstraintType` 表示类型参数要满足的条件，即`TypeParameter` 是 `ConstraintType` 的子类型。
```ts
function comp<T extends { length: number }>( a: T, b: T ) {
  if (a.length >= b.length) {
    return a;
  }
  return b;
}

comp([1, 2], [1, 2, 3]) // 正确
comp('ab', 'abc') // 正确
comp(1, 2) // 报错
```
如果有多个类型参数，一个类型参数的约束条件，可以引用其他参数。
```ts
<T, U extends T>
// 或者
<T extends U, U>
```
**C 使用注意点**
（1）尽量少用泛型。
（2）类型参数越少越好。
```ts
function filter<T, Fn extends (arg:T) => boolean>(arr:T[], func:Fn): T[] {
  return arr.filter(func);
}
// good
function filter<T>(arr:T[], func:(arg:T) => boolean): T[] {
  return arr.filter(func);
}
```
（3）类型参数需要出现两次。如果类型参数在定义后只出现一次，那么很可能是不必要的。
（4）泛型可以嵌套。
类型参数可以是另一个泛型。
```ts
type OrNull<Type> = Type|null;
type OneOrMany<Type> = Type|Type[];
type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;
```

## 6、枚举
### 6.1 简介
枚举可以将相关常量放在一个容器里面。
建议谨慎使用 `Enum` 结构，因为它不仅仅是类型，还会为编译后的代码加入一个对象，所以不能有与它同名的变量（包括对象、函数、类等）。
`Enum` 结构比较适合的场景是，成员的值不重要，名字更重要，从而增加代码的可读性和可维护性。
```ts
enum Color {
  Red,     // 0
  Green,   // 1
  Blue     // 2
}
// 编译后
let Color = {
  Red: 0,
  Green: 1,
  Blue: 2
};

let c:Color = Color.Green; // 正确 Color类型的语义更好
let c:number = Color.Green; // 正确

// Enum 结构可以被对象的as const断言替代
const Color = {
  A: 0,
  B: 1,
  C: 2,
} as const;
```
**A Enum 成员的值**
`Enum` 成员默认不必赋值，系统会从零开始逐一递增，按照顺序为每个成员赋值。
成员的值可以是任意数值，但不能是大整数（`Bigint`）。
成员的值可以相同。
如果只设定第一个成员的值，后面成员的值就会从这个值开始递增。
`Enum` 成员的值也可以使用计算式。
`Enum` 成员值都是只读的，不能重新赋值。为了让这一点更醒目，通常会在 `enum` 关键字前面加上 `const` 修饰，表示这是常量，不能再次赋值。编译为 `JavaScript` 代码后，代码中 `Enum` 成员会被替换成对应的值，这样能提高性能表现。
```ts
enum Color {
  Red, // 0
  Green = 7,
  Blue, // 8
  Yes = Math.random(),
}

// 由于 Enum 结构前面加了const关键字，所以编译产物里面就没有生成对应的对象，而是把所有 Enum 成员出现的场合，都替换成对应的常量
const enum Color {
  Red,
  Green,
  Blue
}
const x = Color.Red;
const y = Color.Green;
const z = Color.Blue;
// 编译后
const x = 0 /* Color.Red */;
const y = 1 /* Color.Green */;
const z = 2 /* Color.Blue */;
```
**B 字符串 `Enum`**
字符串枚举的所有成员值，都必须显式设置。如果没有设置，成员值默认为数值，且位置必须在字符串成员之前。
变量类型如果是字符串 `Enum`，就不能再赋值为字符串，这跟数值 `Enum` 不一样。字符串 `Enum` 作为一种类型，有限定函数参数的作用。
字符串 `Enum` 可以使用联合类型（`union`）代替。
字符串 `Enum` 的成员值，不能使用表达式赋值。
```ts
// Enum 成员可以是字符串和数值混合赋值
enum Foo {
  A, // 0
  B = 'hello',
  C // 报错
}

enum MyEnum {
  One = 'One',
  Two = 'Two',
}
function f(arg:MyEnum) {
  return 'arg is ' + arg;
}
f('One') // 报错
```
**C `keyof` 运算符**
`keyof` 运算符可以取出 `Enum` 结构的所有成员名，作为联合类型返回。
`Enum` 作为类型，本质上属于 `number` 或 `string` 的一种变体，而 `typeof MyEnum` 会将 `MyEnum` 当作一个值处理，从而先其转为对象类型，就可以再用 `keyof` 运算符返回该对象的所有属性名。
```ts
enum MyEnum {
  A = 'a',
  B = 'b'
}
type Foo = keyof typeof MyEnum; // 'A'|'B'
type Foo = { [key in MyEnum]: any }; // { a: any, b: any }
```
**D 反向映射**

数值 `Enum` 存在反向映射，即可以通过成员值获得成员名。
```ts
enum Weekdays {
  Monday = 1,
  Tuesday,
  Wednesday,
}
console.log(Weekdays[2]) // Tuesday
// 编译后
var Weekdays;
(function (Weekdays) {
    Weekdays[Weekdays["Monday"] = 1] = "Monday"; // 等价于 Weekdays["Monday"] = 1; Weekdays[1] = "Monday";
    Weekdays[Weekdays["Tuesday"] = 2] = "Tuesday";
    Weekdays[Weekdays["Wednesday"] = 3] = "Wednesday";
})(Weekdays || (Weekdays = {}));
```
对于字符串 `Enum`，不存在反向映射。这是因为字符串 `Enum` 编译后只有一组赋值。
```ts
enum MyEnum {
  A = 'a',
  B = 'b'
}
// 编译后
var MyEnum;
(function (MyEnum) {
    MyEnum["A"] = "a";
    MyEnum["B"] = "b";
})(MyEnum || (MyEnum = {}));
```
### 6.2 同名 `Enum` 的合并
多个同名的 `Enum` 结构会自动合并，只允许其中一个的首成员省略初始值，否则报错。
同名 `Enum` 合并时，不能有同名成员，否则报错。
所有定义必须同为 `const` 枚举或者非 `const` 枚举，不允许混合使用。
同名 `Enum` 的合并，最大用处就是补充外部定义的 `Enum` 结构。
```ts
enum Foo {
  A,
  B
}
enum Foo {
  B = 1, // 报错
  C
}
```

