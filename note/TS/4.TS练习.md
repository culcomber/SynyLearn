## Easy

### 1、`Pick`

从类型 T 中选出符合 K 的属性，构造一个新的类型

`extends` ：`interface` 和 `class` 继承，`type` 不可以继承，使用 `&` 添加属性

`in`：确定对象是否包含某个属性名，主要用于数组和对象的构建，不要用于 `interface` 会报错

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}
type TodoPreview = MyPick<Todo, 'title' | 'completed'>
const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
}
// 实现
type MyPick<T, K extends keyof T> = {
  [key in K]: T[key];
}
```

用于实际开发例子：

```ts
function getValue(o:object, key: string){
  return o[key]
}
const obj1 = { name: '张三', age: 18 }
const values = getValue(obj1, 'name')
```

这样写丧失了ts的优势：

1. 无法确定返回值类型
2. 无法对key进行约束

```ts
function getValue<T extends Object,K extends keyof T>(o: T,key: K): T[K] {
  return o[key]
}
const obj1 = { name: '张三'， age: 18}
const values = getValue(obj1, 'name') // 如果第二个参数不是obj1中的参数就会报错
```

### 2、`Readonly`

泛型 `Readonly<T>` 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会是只读 (readonly) 的

```ts
interface Todo {
  title: string
  description: string
}
const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}
todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
// 实现
type MyReadonly<T> = {
  readonly [prop in keyof T]: T[prop];
}
```

`readonly` 类属性名 接口属性名

`Readonly<Type>`返回一个新类型，将参数类型`Type`的所有属性变为只读属性

`ReadonlyArray<Type>`只读数组

```ts
let x: readonly string[] = ['x'];
let y: ReadonlyArray<string> = ['y'];

class Greeter {
  readonly name: string = "world";
}
interface SomeType {
  readonly prop: string;
}

interface Todo {
  title: string;
}
const todo: Readonly<Todo> = {
  title: "Delete inactive users",
};
```

### 3、`TupleToObject`

元组：`TypeScript` 特有的数据类型，表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。

将一个元组类型转换为对象类型，这个对象类型的键/值和元组中的元素对应。

```ts
const tuple = ['tesla', 'model 3'] as const
type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3' }
// 实现
type TupleToObject<T extends readonly (string | number | symbol)[]> = {
  [prop in T[number]]: prop;
}
```

`keyof` 返回对象的所有键名组成的联合类型

`[]`用于取出对象的键值类型，参数可以是属性名的索引类型，数组/元组键名是`number`，对象键名是`string | number | symbol`

### 4、`First<T>`

实现一个`First<T>`泛型，它接受一个数组`T`并返回它的第一个元素的类型。

```ts
type arr1 = ['a', 'b', 'c']
type head1 = First<arr1> // 应推导出 'a'
// 实现
type First<T extends any[]> = T extends [] ? never : T[0] //answer1
type First<T extends any[]> = T['length'] extends 0 ? never : T[0] //answer2
type First<T extends any[]> = T extends [infer A, ...infer rest] ? A : never //answer3
```

`Type extends Array<infer Item>`则表示，如果参数`Type`是一个数组，那么就将该数组的成员类型推断为`Item`，即`Item`是从`Type`推断出来的

`infer`可以提取`T`的类型

```ts
type MyType<T> = T extends { a: infer M, b: infer N } ? [M, N] : never;
type T = MyType<{ a: string; b: number }>; // [string, number]
```

`extends` 返回 `never` 可以剔除

`[]`参数可以是具体值

`[infer A, ...infer rest]`不是[方括号运算符](https://wangdoc.com/typescript/operator#方括号运算符)而是构建数组类型，`infer`从构建类型中取值

### 5、`Length<T>`

创建一个`Length<T>`，这个`T`接受一个只读的元组，返回这个元组的长度。

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type teslaLength = Length<tesla> // expected 4

// 实现
type Length<T extends readonly any[]> = T['length']; //answer1
type Length<T extends readonly any[]> = T extends { length: infer L }  ?  L : never; //answer2
```

元组本质是数组，对`T`进行数组的约束，在`[]`使用`length`获取到具体值

### 6、 `Exclude<T, U>` 

从联合类型 `T` 中排除 `U` 中的类型，来构造一个新的类型。

```ts
type Result = MyExclude<'a' | 'b' | 'c', 'a'> // 'b' | 'c'
// 实现
type MyExclude<T, U> = T extends U ? never : T;
```

如果需要判断的类型是一个联合类型，那么条件运算符会展开这个联合类型。

```ts
(A|B) extends U ? X : Y
// 等同于
(A extends U ? X : Y) | (B extends U ? X : Y)
```

### 7、`Awaited<T>`

在 TS 中，我们用 `Promise` 中的 `T` 来描述这个 `Promise` 返回的类型。请你实现一个类型，可以获取这个类型。

例如：`Promise<ExampleType>`，请你返回 `ExampleType` 类型。

```ts
type ExampleType = Promise<string>
type Result = MyAwaited<ExampleType> // string
// 实现
type MyAwaited<T extends PromiseLike<any>> = T extends PromiseLike<infer U>
  ? U extends PromiseLike<any>
    ? MyAwaited<U>
    : U
  : never;
// or
type Thenable<T> = {
  then: (onfulfilled: (arg: T) => unknown) => unknown;
}
type MyAwaited<T extends Thenable<any> | Promise<any>> = T extends Promise<infer Inner>
  ? Inner extends Promise<any> 
    ? MyAwaited<Inner> 
    : Inner
  : T extends Thenable<infer U> 
    ? U 
	: false
```

`PromiseLike`少了个`catch` 和`finally` 的定义，比`Promise`定义宽松得多。

### 8、`IF` 

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。 `C` 只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

```ts
type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
// 实现
type If<C extends boolean, T, F> = C extends true ? T : F;
```

### 9、`Concat`

在类型系统里实现 `JavaScript` 内置的 `Array.concat` 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。

```ts
type Result = Concat<[1], [2]> // expected to be [1, 2]
// 实现
type Concat<T extends readonly any[], U extends readonly any[]> = [...T,...U]
// or 推荐
type Concat<T extends readonly unknown[], U extends readonly unknown[]> = [...T,...U]
```

要限制`T`为数组，这样才可以在`[...T,...U]`中使用扩展运算符

`unknown`比`any`安全

```ts
function f1(a: any) {
  a.b(); // OK
}
function f2(a: unknown) {
  a.b(); // error 'a' is of type 'unknown'
}
```

### 10、`Includes`

在类型系统里实现 `JavaScript` 的 `Array.includes` 方法，这个类型接受两个参数，返回的类型要么是 `true` 要么是 `false`。

```ts
type isPillarMen = Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'> // expected to be `false`
// 实现
type IsEqual<T, U> =
	(<G>() => G extends T ? 1 : 2) extends
	(<G>() => G extends U ? 1 : 2)
		? true
		: false;

type Includes<Value extends any[], Item> =
	IsEqual<Value[0], Item> extends true
		? true
		: Value extends [Value[0], ...infer rest]
			? Includes<rest, Item>
			: false;
```

### 11、`Push` /`unshift`

在类型系统里实现通用的 `Array.push` 。

```typescript
type Result = Push<[1, 2], '3'> // [1, 2, '3']
// 实现
type Push<T extends unknown[], U> = [...T, U]
```

实现类型版本的 `Array.unshift`。

```typescript
type Result = Unshift<[1, 2], 0> // [0, 1, 2,]
// 实现
type Unshift<T extends unknown[], U> = [U, ...T]
```

### 12、`Parameters `/`ReturnType`

实现内置的 `Parameters` 类型

```ts
const foo = (arg1: string, arg2: number): void => {}
type FunctionParamsType = MyParameters<typeof foo> // [arg1: string, arg2: number]                           
// 实现
type MyParameters<T extends (...args: any[]) => any> = 
  T extends (...any: infer S) => any 
    ? S 
    : any 
```

不使用 `ReturnType` 实现 `TypeScript` 的 `ReturnType<T>` 泛型。

```ts
const fn = (v: boolean) => {
  if (v)
    return 1
  else
    return 2
}
type a = MyReturnType<typeof fn> // 应推导出 "1 | 2"
// 实现
type MyReturnType<T extends Function> =
  T extends (...args: any) => infer R
    ? R
    : never
```

## Medium
