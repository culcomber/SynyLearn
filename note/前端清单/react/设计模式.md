<img src="C:\Users\SamTL\AppData\Roaming\Typora\typora-user-images\image-20230512160126724.png" alt="image-20230512160126724" style="zoom:50%;" />

## 1、创建型——对象的创建

主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。

### 1.1 单例模式

- 单例模式用来创建全局唯一的对象
- Share a single global instance throughout our application


- 这个单一的实例可以在应用中共享，适合管理应用程序中的**全局状态**。推荐使用 **`Redux`** or **React Context** 管理 `global state` ，因为可以确保全局状态按照我们的意图被改变，组件不能直接更新状态。


```js
let instance;
let counter = 0;
 
class Counter {
  constructor() {
    if (instance) { // 只能有一个实例
      throw new Error("You can only create one instance!");
    }
    instance = this;
  }
 
  getInstance() {
    return this;
  }
 
  getCount() {
    return counter;
  }
 
  increment() {
    return ++counter;
  }
 
  decrement() {
    return --counter;
  }
}
 
const singletonCounter = Object.freeze(new Counter()); // 不允许修改
export default singletonCounter;
```

### 1.2 工厂模式

- 工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。
- Use a factory function in order to create objects


- 工厂模式不使用new关键字而返回一个对象的函数，用来创建可配置对象

```js
const createUser = ({ firstName, lastName, email }) => ({
  firstName,
  lastName,
  email,
  fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
});

// 使用class可以达到同样效果，并且更节约内存
class User {
  constructor(firstName, lastName, email) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
  }
 
  fullName() { // new创建实例共享这个方法
    return `${this.firstName} ${this.lastName}`;
  }
}
```

### 1.3 原型模式

- 原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。
- Share properties among many objects of the same type

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log("Woof!");
  }
}

class SuperDog extends Dog {
  constructor(name) {
    super(name);
  }

  fly() {
    console.log(`Flying!`);
  }
}

const dog1 = new SuperDog("Daisy");
dog1.bark();
dog1.fly();
```

<img src="C:\Users\SamTL\AppData\Roaming\Typora\typora-user-images\image-20230517160651036.png" alt="image-20230517160651036" style="zoom:60%;" />

## 2、结构型——类或对象的组合

主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。

常用

- 代理模式6
- 桥接模式
- 装饰器模式15
- 适配器模式17

不常用

- 门面模式
- 组合模式10
- 享元模式12

2.1 代理模式

代理者处理复杂逻辑，被代理者实现基本功能

```js
/**************** 计算乘积 *****************/ 
var mult = function(){ 
 var a = 1; 
 for ( var i = 0, l = arguments.length; i < l; i++ ){ 
 a = a * arguments[i]; 
 } 
 return a; 
}; 
/**************** 计算加和 *****************/ 
var plus = function(){ 
 var a = 0; 
 for ( var i = 0, l = arguments.length; i < l; i++ ){ 
 a = a + arguments[i]; 
 } 
 return a; 
}; 
/**************** 创建缓存代理的工厂 *****************/ 
var createProxyFactory = function( fn ){ 
 var cache = {}; 
 return function(){ 
 var args = Array.prototype.join.call( arguments, ',' ); 
 if ( args in cache ){ 
 return cache[ args ]; 
 } 
 return cache[ args ] = fn.apply( this, arguments ); 
 } 
}; 
var proxyMult = createProxyFactory( mult ), 
proxyPlus = createProxyFactory( plus ); 
alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24 
alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24 
alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10 
alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10
```

2.2 装饰器模式



## 3、行为型——类或对象之间的交互

常用

- 观察者模式8
- 模板模式11
- 策略模式5
- 职责链模式13
- 迭代器模式7
- 状态模式16

不常用

- 访问者模式
- 备忘录模式
- 命令模式9
- 解释器模式
- 中介模式14



