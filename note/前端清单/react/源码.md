## 1、React理念

### 1.1 React理念

React 是用 JavaScript 构建**快速响应**的大型 Web 应用程序的首选方式。

浏览网页时，有两类场景会制约`快速响应`：

- 当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。（CPU的瓶颈）
- 发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。（IO的瓶颈）

React解决问题

- 解决`CPU瓶颈`的关键是实现`时间切片`（将长任务分拆到每一帧中，一次执行一小段任务的操作），而`时间切片`的关键是：将**同步的更新**变为**可中断的异步更新**。

- 在`网络延迟`客观存在的情况下，通过将人机交互研究的结果整合到真实的 UI 中，减少用户对`网络延迟`的感知。为此，`React`实现了[Suspense](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html)功能及配套的`hook`——[useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue)。而在源码内部，为了支持这些特性，同样需要将**同步的更新**变为**可中断的异步更新**。


**todo**

[React理念 (opens new window)](https://zh-hans.reactjs.org/docs/thinking-in-react.html)

[将人机交互研究的结果整合到真实的 UI 中 (opens new window)](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production)

[「英文」尤雨溪论JavaScript框架设计哲学：平衡](https://www.bilibili.com/video/BV134411c7Sk?from=search&seid=17404881291635824595)

[「英文 外网」Building a Custom React Renderer | React前经理Sophie Alpert](https://www.youtube.com/watch?v=CGpMlWVcHok&list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&index=7)

### 1.2  React15架构

React15架构可以分为两层：

- Reconciler（协调器）—— 负责找出变化的组件

  每当有更新发生时，**Reconciler**会做如下工作：

  - 调用函数组件、或class组件的`render`方法，将返回的JSX转化为虚拟DOM
  - 将虚拟DOM和上次更新时的虚拟DOM对比
  - 通过对比找出本次更新中变化的虚拟DOM
  - 通知**Renderer**将变化的虚拟DOM渲染到页面上

- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

  `React`支持跨平台，不同平台有不同的**Renderer**：

  - [ReactDOM (opens new window)](https://www.npmjs.com/package/react-dom)渲染器，渲染浏览器

  - [ReactNative (opens new window)](https://www.npmjs.com/package/react-native)渲染器，渲染App原生组件
  - [ReactTest (opens new window)](https://www.npmjs.com/package/react-test-renderer)渲染器，渲染出纯Js对象用于测试
  - [ReactArt (opens new window)](https://www.npmjs.com/package/react-art)渲染器，渲染到Canvas, SVG 或 VML (IE8)

在**Reconciler**中，`mount`的组件会调用[mountComponent (opens new window)](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498)，`update`的组件会调用[updateComponent (opens new window)](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877)，两个方法都会**递归**更新子组件。递归更新不能中途终止，也就是更新不支持异步，就会影响性能。

```js
import React from "react";

export default class App extends React.Component {
  constructor(...props) {
    super(...props);
    this.state = {
      count: 1
    };
  }
  onClick() {
    this.setState({
      count: this.state.count + 1
    });
  }
  render() {
    return (
      <ul>
        <button onClick={() => this.onClick()}>乘以{this.state.count}</button>
        <li>{1 * this.state.count}</li>
        <li>{2 * this.state.count}</li>
        <li>{3 * this.state.count}</li>
      </ul>
    );
  }
}
```

Reconciler和Renderer是交替工作，整个过程都是同步的

<img src="https://react.iamkasong.com/img/v15.png" alt="更新流程" style="zoom:30%;" />

如果中途中断更新

<img src="https://react.iamkasong.com/img/dist.png" alt="中断更新流程" style="zoom:30%;" />

### 1.3 React16架构

React16架构可以分为三层：

- Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入**Reconciler**

- Reconciler（协调器）—— 负责找出变化的组件

  更新工作从递归变成了可以中断的循环过程，`Reconciler`内部采用了`Fiber`的架构

- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM

<img src="C:\Users\SamTL\AppData\Roaming\Typora\typora-user-images\image-20230614105754188.png" alt="image-20230614105754188" style="zoom:40%;" />

### 1.4 `Fiber`

**algebraic effects are much more flexible than `try / catch`, and recoverable errors are just one of many possible use cases**

**algebraic effects can be a very powerful instrument to separate the \*what\* from the \*how\* in the code.**

```js
function getName(user) {
  let name = user.name;
  if (name === null) {
  	throw new Error('A girl has no name');
  }
  return name;
}

function makeFriends(user1, user2) {
  user1.friendNames.add(getName(user2));
  user2.friendNames.add(getName(user1));
}

const arya = { name: null };
const gendry = { name: 'Gendry' };
try {
  makeFriends(arya, gendry);
} catch (err) {
  console.log("Oops, that didn't work out: ", err);
}
```



```js
function getName(user) {
  let name = user.name;
  if (name === null) {
  	// 1. 我们在这里执行效应
  	name = perform 'ask_name';
  	// 4. ...最后回到这里（现在 name 是 'Arya Stark'）了
  }
  return name;
}

// ...

try {
  makeFriends(arya, gendry);
} handle (effect) {
  // 2. 我们进入处理程序（类似 try/catch）
  if (effect === 'ask_name') {
  	// 3. 但是这里我们可以带一个值继续执行（与 try/catch 不同!）
  	resume with 'Arya Stark';
  }
}
```

