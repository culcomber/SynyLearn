## 1、React理念

### 1.1 快速响应

React 是用 JavaScript 构建**快速响应**的大型 Web 应用程序的首选方式。

浏览网页时，有两类场景会制约`快速响应`：

- 当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。（CPU的瓶颈）
- 发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。（IO的瓶颈）

React解决问题

- 解决`CPU瓶颈`的关键是实现`时间切片`（将长任务分拆到每一帧中，一次执行一小段任务的操作），而`时间切片`的关键是：将**同步的更新**变为**可中断的异步更新**。

- 在`网络延迟`客观存在的情况下，通过将人机交互研究的结果整合到真实的 UI 中，减少用户对`网络延迟`的感知。为此，`React`实现了[Suspense](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html)功能及配套的`hook`——[useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue)。而在源码内部，为了支持这些特性，同样需要将**同步的更新**变为**可中断的异步更新**。


**todo**

[React理念 (opens new window)](https://zh-hans.reactjs.org/docs/thinking-in-react.html)

[将人机交互研究的结果整合到真实的 UI 中 (opens new window)](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#putting-research-into-production)

[「英文」尤雨溪论JavaScript框架设计哲学：平衡](https://www.bilibili.com/video/BV134411c7Sk?from=search&seid=17404881291635824595)

[「英文 外网」Building a Custom React Renderer | React前经理Sophie Alpert](https://www.youtube.com/watch?v=CGpMlWVcHok&list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&index=7)

最早的`Fiber`官方解释来源于[2016年React团队成员Acdlite的一篇介绍 (opens new window)](https://github.com/acdlite/react-fiber-architecture)。

[Lin Clark - A Cartoon Intro to Fiber - React Conf 2017](https://www.bilibili.com/video/BV1it411p7v6?from=search&seid=3508901752524570226)

[贡献流程](https://zh-hans.react.dev/blog/2023/03/16/introducing-react-dev)

在React17中，已经不需要显式导入React了。详见[介绍全新的 JSX 转换](https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)

- [如何干掉知乎的全部DIV -- 通过这篇文章在运行时修改`React.createElement`达到消除页面所有`div`元素的效果(opens new window)](https://mp.weixin.qq.com/s/ICjOlJL-fUGRb2S_xqBT7Q)
- [React官网Blog，关于React Component, Element, Instance, Reconciliation的简介](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)

### 1.2  React15架构

React15架构可以分为两层：

- Reconciler（协调器）—— 负责找出变化的组件

  每当有更新发生时，**Reconciler**会做如下工作：

  - 调用函数组件、或class组件的`render`方法，将返回的JSX转化为虚拟DOM
  - 将虚拟DOM和上次更新时的虚拟DOM对比
  - 通过对比找出本次更新中变化的虚拟DOM
  - 通知**Renderer**将变化的虚拟DOM渲染到页面上

- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

  `React`支持跨平台，不同平台有不同的**Renderer**：

  - [ReactDOM (opens new window)](https://www.npmjs.com/package/react-dom)渲染器，渲染浏览器

  - [ReactNative (opens new window)](https://www.npmjs.com/package/react-native)渲染器，渲染App原生组件
  - [ReactTest (opens new window)](https://www.npmjs.com/package/react-test-renderer)渲染器，渲染出纯Js对象用于测试
  - [ReactArt (opens new window)](https://www.npmjs.com/package/react-art)渲染器，渲染到Canvas, SVG 或 VML (IE8)

在**Reconciler**中，`mount`的组件会调用[mountComponent (opens new window)](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498)，`update`的组件会调用[updateComponent (opens new window)](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877)，两个方法都会**递归**更新子组件。递归更新不能中途终止，也就是更新不支持异步，就会影响性能。

```js
import React from "react";

export default class App extends React.Component {
  constructor(...props) {
    super(...props);
    this.state = {
      count: 1
    };
  }
  onClick() {
    this.setState({
      count: this.state.count + 1
    });
  }
  render() {
    return (
      <ul>
        <button onClick={() => this.onClick()}>乘以{this.state.count}</button>
        <li>{1 * this.state.count}</li>
        <li>{2 * this.state.count}</li>
        <li>{3 * this.state.count}</li>
      </ul>
    );
  }
}
```

Reconciler和Renderer是交替工作，整个过程都是同步的

<img src="https://react.iamkasong.com/img/v15.png" alt="更新流程" style="zoom:30%;" />

如果中途中断更新

<img src="https://react.iamkasong.com/img/dist.png" alt="中断更新流程" style="zoom:30%;" />

### 1.3 React16架构

React16架构可以分为三层：

- Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入**Reconciler**

- Reconciler（协调器）—— 负责找出变化的组件

  更新工作从递归变成了可以中断的循环过程，`Reconciler`内部采用了`Fiber`的架构

- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM

<img src="../../assets/image-20230614105754188.png" alt="image-20230614105754188" style="zoom:40%;" />

<img src="../../assets/240487936f31fcaecbc23fa29ca309e.png" alt="240487936f31fcaecbc23fa29ca309e" style="zoom:50%;" />

### 1.4 `Fiber`

#### 1.4.1 代数效应

**基本概念**

代数：把数字代进去参与公式计算

代数效应：将程序执行的操作像代数一样，代入到另一块操作中

以实际代码为例，首先设定如下：

- 我们规定用 `perform` 关键词表示此处需要代入效应。代码执行到此处，将程序中断，告诉另一处需要传一个效应回来；
- 另一处接收到请求后，执行所需的逻辑，通过 `resume` 将效应执行的结果返回到中断处，再恢复程序；
- 为了便于捕获 `perform` 请求，我们令代数效应有形似 `try… catch` 的结构，令其为 `try… handle`。这样只要在 `try` 里包裹的代入效应请求，都能被外层接收并处理。

- 实际代数效应比 `try / catch`更复杂，这里只是举例，algebraic effects are much more flexible than `try / catch`, and recoverable errors are just one of many possible use cases

- algebraic effects can be a very powerful instrument to separate the *what* from the *how* in the code


```js
function getName(user) {
  let name = user.name;
  if (name === null) {
  	throw new Error('A girl has no name');
  }
  return name;
}

function makeFriends(user1, user2) {
  user1.friendNames.add(getName(user2));
  user2.friendNames.add(getName(user1));
}

const arya = { name: null };
const gendry = { name: 'Gendry' };
try {
  makeFriends(arya, gendry);
} catch (err) {
  console.log("Oops, that didn't work out: ", err);
}
```

应用代数效应

```js
function getName(user) {
  let name = user.name;
  if (name === null) {
  	// 1. 我们在这里执行效应
  	name = perform 'ask_name';
  	// 4. ...最后回到这里（现在 name 是 'Arya Stark'）了
  }
  return name;
}

// ...

try {
  makeFriends(arya, gendry);
} handle (effect) {
  // 2. 我们进入处理程序（类似 try/catch）
  if (effect === 'ask_name') {
  	// 3. 但是这里我们可以带一个值继续执行（与 try/catch 不同!）
  	resume with 'Arya Stark';
  }
}
```

**代数效应的作用**

```js
// 假设有这样一个需求，从数据库中读取 userName，基本代码如下：
const getUserName = (userId) => doSthToGetUserName(userId);
const main = () => {
  const userName = getUserName(123);
  console.log(userName);
};
```

避免由内而外的层层污染

```js
// 如果是异步环境，即 userName 从网络请求获取，就得用上 async/await：
const getUserName = async (userId) => (await axios.get(`/db/${userId}`)).data;
// async/await 具有传染性。既然 getUserName 是异步函数，调用它的 main 函数也要写成异步的
const main = async () => {
  const userName = await getUserName(123);
  console.log(userName);
};

// 用代数效应改写上面逻辑如下：
const getUserName = (userId) => {
  try {
    perform ({ userId }); // 中断，等待获取 userId
  } handle (effect) {
    // -- 对于同步 ------
    resume localStorage.get(effect.userId); // 立刻恢复

    // -- 对于异步 ------
    axios.get(`/db/${effect.userId}`).then(resp=>{
      resume resp.data; // 请求完成后恢复
    })
  }
};

// main 仍保持原来写法
const main = () => {
  const userName = getUserName(123);
  console.log(userName);
};
```

避免由外而内的层层传递

```js
// 为了灵活性，将 getUserName 作为依赖注入到程序中，从而在不同场景下实现不同的逻辑。
const implGetUserName = (userId) => localStorage.get(userId); // 同步环境将注入的依赖
const implGetUserNameAsync = (userId) => axios.get(`/db/${userId}`); // 异步环境将注入的依赖
// 内层接受注入的依赖
const getUserName = (userId, implGetUserName) => implGetUserName(userId);
// 外层接受注入的依赖，并传递给内层
const main = (implGetUserName) => {
  const userName = getUserName(userId, implGetUserName);
  console.log(userName);
};

// 可以用代数效应改写如下：
const getUserName = (userId) => {
  const userName = perform ({ userId }); // 等待外层的注入依赖执行完回传
  return userName;
};

const main = () => {
  const userName = getUserName(123);
  console.log(userName);
};

// 由于代数效应类似 try…catch 的特性，只要在调用 main 的地方的外层包裹 try…handle 就行
try {
  main();
} handle (effect) {
  // -- 同步时注入的依赖 ------
  resume localStorage.get(effect.userId);

  // -- 异步时注入的依赖 ------
  axios.get(`/db/${effect.userId}`).then(resp=>{
    resume resp.data;
  })
}
```

**React 与代数效应**

- Fiber：代数效应一个特点就是代码的可中断性，React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态
-  [`<Suspense />`](https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160)：当内层任一组件处于 loading 状态，都能触发最外层 `Suspense` 进入 fallback 状态

- hooks
  - useState：函数组件本身并没有能力保存 state 的状态，但每次使用时都能拿到一个 stateful 的值，这就是因为在调用 useState 时进行了中断，将效应抛出给 React，由它获取到 state 值后，代入回组件函数。
  - useContext：从内层组件可以随时获取到最外层的 context value，而无需层层传递。

[参考](https://mongkii.com/blog/2021-05-08-talk-about-algebraic-effects)

#### 1.4.2 Fiber架构的实现原理

`Fiber`包含三层含义：

1. 作为架构来说，之前`React15`的`Reconciler`采用递归的方式执行，数据保存在递归调用栈中，所以被称为`stack Reconciler`。`React16`的`Reconciler`基于`Fiber节点`实现，被称为`Fiber Reconciler`。`Fiber` 代替`React15`不可中断的`虚拟DOM`。

   ```jsx
   function App() {
     return (
       <div>
         i am
         <span>KaSong</span>
       </div>
     )
   }
   ```

   <img src="../../assets/image-20230615100342591.png" alt="image-20230615100342591" style="zoom:40%;" />

2. 作为静态的数据结构来说，保存了组件相关的信息，**每个`Fiber节点`对应一个`React element`**，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。

3. 作为动态的工作单元来说，每个`Fiber节点`保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

#### 1.4.3 Fiber架构的工作原理

**“双缓存”**

- 用`canvas`绘制动画，每一帧绘制前都会调用`ctx.clearRect`清除上一帧的画面。如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。

- 为了解决这个问题，可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。

**双缓存Fiber树**

`React`使用“双缓存”来完成`Fiber树`的构建与替换——对应着`DOM树`的创建与更新。

在`React`中最多会同时存在两棵`Fiber树`：

- 当前屏幕上显示内容对应的`Fiber树`称为`current Fiber树`，其中的`Fiber节点`被称为`current fiber`

- 正在内存中构建的`Fiber树`称为`workInProgress Fiber树`，其中的`Fiber节点`被称为`workInProgress fiber`

- 两棵树通过`alternate`属性连接

  ```js
  currentFiber.alternate === workInProgressFiber;
  workInProgressFiber.alternate === currentFiber;
  ```

`React`应用的根节点通过使`current`指针在不同`Fiber树`的`rootFiber`间切换来完成`current Fiber`树指向的切换

```jsx
function App() {
  const [num, add] = useState(0);
  return (
    <p onClick={() => add(num + 1)}>{num}</p>
  )
}

ReactDOM.render(<App/>, document.getElementById('root'));
```

**mount**

- 首次执行`ReactDOM.render`会创建`fiberRootNode`（源码中叫`fiberRoot`）和`rootFiber`
  - `fiberRootNode`是整个应用的根节点
  - `rootFiber`是`<App/>`所在组件树的根节点
  - `fiberRootNode`的`current`会指向当前页面上已渲染内容对应`Fiber`树，即`current Fiber`树
- 在构建`workInProgress Fiber树`时会尝试复用`current Fiber树`中已有的`Fiber节点`内的属性

<center><img src="../../assets/image-20230615101138339.png" alt="image-20230615101138339" style="zoom:20%;" /><img src="../../assets/image-20230615101211041.png" alt="image-20230615101211041" style="zoom:30%;" /><img src="../../assets/image-20230615101240727.png" alt="image-20230615101240727" style="zoom:30%;" /></center>

**update**

<img src="../../assets/image-20230615101409580.png" alt="image-20230615101409580" style="zoom:30%;" /><img src="../../assets/image-20230615101430078.png" alt="image-20230615101430078" style="zoom:30%;" />

### 1.5 深入理解JSX

`JSX`在编译时会被Babel编译为`React.createElement`方法，这也是为什么在每个使用`JSX`的`JS`文件中，你必须显式的声明，否则在运行时该模块内就会报`未定义变量 React`的错误。

```js
import React from 'react';
```

所有`JSX`在运行时的返回结果（即`React.createElement()`的返回值）都是`React Element`

React通过`ClassComponent`实例原型上的`isReactComponent`变量判断是否是`ClassComponent`

```JS
class AppClass extends React.Component {
  render() {
    return <p>KaSong</p>
  }
}
console.log('这是ClassComponent：', AppClass);
console.log('这是Element：', <AppClass/>);


function AppFunc() {
  return <p>KaSong</p>;
}
console.log('这是FunctionComponent：', AppFunc);
console.log('这是Element：', <AppFunc/>);
            
AppClass instanceof Function === true;
AppFunc instanceof Function === true;
```

<img src="image-20230614230212897.png" alt="image-20230614230212897" style="zoom:73%;" />

**JSX与Fiber节点**

`JSX`是一种描述当前组件内容的数据结构，不包含组件**schedule**、**reconcile**、**render**所需的相关信息。比如如下信息就不包括在`JSX`中，这些内容都包含在`Fiber节点`中：

- 组件在更新中的`优先级`
- 组件的`state`
- 组件被打上的用于**Renderer**的`标记`

组件`mount`时，`Reconciler`根据`JSX`描述的组件内容生成组件对应的`Fiber节点`。

在`update`时，`Reconciler`将`JSX`与`Fiber节点`保存的数据对比，生成组件对应的`Fiber节点`，并根据对比结果为`Fiber节点`打上`标记`。

## 2、架构篇——render阶段 

`Fiber节点`是如何被创建并构建`Fiber树`

### 2.1 流程概览

`render阶段`开始于`performSyncWorkOnRoot`或`performConcurrentWorkOnRoot`方法的调用。这取决于本次更新是同步更新还是异步更新。

```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    // workInProgress代表当前已创建的workInProgress fiber
    // performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress
    // 并将workInProgress与已创建的Fiber节点连接起来构成Fiber树
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  // 如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

如果将`performUnitOfWork`转化为递归版本（React15），大体代码如下：

```js
function performUnitOfWork(fiber) {
  // 执行beginWork
  if (fiber.child) {
    performUnitOfWork(fiber.child);
  }

  // 执行completeWork
  if (fiber.sibling) {
    performUnitOfWork(fiber.sibling);
  }
}
```

`Fiber Reconciler`是从`Stack Reconciler`重构而来，通过遍历的方式实现可中断的递归，所以`performUnitOfWork`的工作可以分为两部分：“递”和“归”。

- “递”阶段

  - 首先从`rootFiber`开始向下深度优先遍历。为遍历到的每个`Fiber节点`调用[beginWork方法 (opens new window)](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)。

  - 该方法会根据传入的`Fiber节点`创建`子Fiber节点`，并将这两个`Fiber节点`连接起来。

  - 当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。

- “归”阶段

  - 在“归”阶段会调用[completeWork (opens new window)](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理`Fiber节点`。

  - 当某个`Fiber节点`执行完`completeWork`，如果其存在`兄弟Fiber节点`（即`fiber.sibling !== null`），会进入其`兄弟Fiber`的“递”阶段。

  - 如果不存在`兄弟Fiber`，会进入`父级Fiber`的“归”阶段。

- “递”和“归”阶段会交错执行直到“归”到`rootFiber`。至此，`render阶段`的工作就结束了。

```jsx
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById("root"));
```

<img src="../../assets/image-20230615102948741.png" alt="image-20230615102948741" style="zoom:30%;" />

```
// render阶段会依次执行：
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
```

### 2.2  beginWork
`beginWork`的工作是传入当前`Fiber`节点，创建子`Fiber`节点

![image-20230615111100824](../../assets/image-20230615111100824.png)

<img src="../../assets/image-20230615111030874.png" alt="image-20230615111030874" style="zoom:50%;" />


###  2.3 completeWork



## 3、架构篇——commit阶段 

### 3.1 流程概览



### 3.2 before mutation阶段



### 3.3 mutation阶段



### 3.4 layout阶段