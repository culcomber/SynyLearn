### 1、数据在内存中的存放

### 1.1 JavaScript 是一种弱类型的、动态的语言

- **弱类型**，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
- **动态**，意味着你可以使用同一个变量保存不同类型的数据。

**JavaScript 的内存模型**

<img src="../../assets/image-20230131094655459.png" alt="image-20230131094655459" style="zoom:50%;" />

```js
function foo(){
    var a = " 极客时间 "
    var b = a
    var c = {name:" 极客时间 "}
    var d = c
}
foo()
```

<img src="../../assets/image-20230131094739470.png" alt="image-20230131094739470" style="zoom:80%;" />

### 1.2 闭包的内存模型

```js
function foo() {
    var myName = " 极客时间 "
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" 极客邦 ")
bar.getName()
console.log(bar.getName())
```

**内存模型的角度分析代码的执行流程**

1. 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。
2. 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。
3. 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。
4. 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。
5. 当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。

<img src="../../assets/image-20230131094807839.png" alt="image-20230131094807839" style="zoom:80%;" />

**产生闭包的核心有两步**

第一步是需要预扫描内部函数

第二步是把内部函数引用的外部变量保存到堆中

### 2、JavaScript 处理垃圾回收

### 2.1 调用栈中的数据回收

- JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

### 2.2 堆中的数据回收

垃圾回收器执行流程

-  第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。 
-  第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。 
-  第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。 

代际假说 - 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问； - 第二个是不死的对象，会活得更久。 - 副垃圾回收器，主要负责新生代（生存时间短的对象）的垃圾回收。 - 主垃圾回收器，主要负责老生代（生存时间久）的垃圾回收。

### 3、V8 执行代码

### 3.1 编译器（Compiler）和 解释器（Interpreter）

<img src="../../assets/image-20230131094847069.png" alt="image-20230131094847069" style="zoom:80%;" />

### 3.2 V8 执行一段 JavaScript 代码

<img src="../../assets/image-20230131094914296.png" alt="image-20230131094914296" style="zoom:80%;" />

- 生成抽象语法树（AST）
  - 第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token
  - 第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST 
-  执行上下文 
-  生成字节码 

<img src="../../assets/image-20230131094937990.png" alt="image-20230131094937990" style="zoom:80%;" />

-  执行代码 
-  即时编译器（JIT） 

具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用

<img src="../../assets/image-20230131094959264.png" alt="image-20230131094959264" style="zoom:80%;" />

### 3.3 JavaScript 的性能优化

1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。