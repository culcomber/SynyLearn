## 基础

deal with sorted arrays (or `LinkedLists`) and need to find a set of elements that fulfill certain constraints

有序数组or链表中找到符合条件的子序列

### 快慢指针

数组问题中比较常见的快慢指针技巧，是让你**原地修改数组**。

数组中另一大类快慢指针的题目就是「滑动窗口算法」

#### 27 移除元素

给你一个数组 `nums` 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

![27.移除元素-双指针法](../../assets/27.移除元素-双指针法.gif)

```js
//时间复杂度：O(n)
//空间复杂度：O(1)
var removeElement = (nums, val) => {
    let k = 0; // 慢指针
    for(let i = 0;i < nums.length;i++){ // i快指针
        if(nums[i] != val){
            nums[k++] = nums[i] // 当不等于val更新快慢指针，等于只更新快指针
        }
    }
    return k;
};
```

**283 移动零**

```js
// 和27类似，只是移除元素是0，然后后面补零
var moveZeroes = function(nums) {
    // 去除 nums 中的所有 0，返回不含 0 的数组长度
    var p = removeElement(nums, 0);
    // 将 nums[p..] 的元素赋值为 0
    for (; p < nums.length; p++) {
        nums[p] = 0;
    }
};

// 方案2，27是不在意后面的元素，可以理解为原地删除，283是讲究后面的顺序，可以理解为原地修改
let slow = 0;
for (let fast = 0; fast < nums.length; fast++) {
    if(nums[fast] !== 0) {
        // 因为要要移动0到末尾，fast和slow交换位置
        let item = nums[fast];
        nums[slow] = nums[fast];
        nums[fast] = item;
        slow++;
    }
} 
return nums;
```

**26 删除排序数组中的重复项**

27 传入value在原数组中删除和value相同元素，fast和value比较

26 在原数组中删除重复项，fast和fast-1比较，或者理解成slow和fast比较

<img src="../../assets/1.gif" alt="image-20230119165825178" style="zoom:50%;" />

```js
// 方案1 理解成slow和fast比较
var removeDuplicates = function(nums) {
	let slow = 0;
    for (let fast = 0; fast < nums.length; fast++) {
        if (nums[fast] !== nums[slow]) {
            nums[++slow] = nums[fast];
        }
    }
    // slow是index下标，真实长度要+1
    return slow + 1; 
};

// 方案2 为了fast可以和fast-1比较，fast从1开始，slow和fast统一，也是从1开始
var removeDuplicates = function(nums) {
    let slow = 1;
    for (let fast = 1; fast < nums.length; fast++) {
        if(nums[fast - 1] !== nums[fast]) {
            nums[slow++] = nums[fast];
        }
    }
    return slow;
}
```

**844 比较含退格的字符串**

**从后面开始遍历**，因为字母是否删除和后面的#相关，只有直到后面有多少#才知道前面有多少字母要删除

```js
var backspaceCompare = function(S, T) {
	let i = S.length - 1,
    j = T.length - 1,
    skipS = 0, // 保存跳过#数量
    skipT = 0;
    while(j >= 0 || i >= 0) {
        // S 循环
        while(i >= 0){
            if(S[i] === '#'){
                skipS++;
                i--;
            } else if (skipS > 0){
                skipS--;
                i--;
            } else break;
        }

        // T 循环
        while(j >= 0) {
            if(T[j] === '#') {
                skipT++;
                j--;
            } else if(skipS > 0) {
                skipT--;
                i--;
            } else break;
        }

        // 如果S和T相同，那么字串也是相同的
        if(S[i] !== T[j]) return false;
        i--;
        j--;
    }
    return true; 
}
```

### 左右指针

**977 有序数组的平方**

```js
var sortedSquares = function(nums) {
// 两头中肯定有最大的，所以新数组从尾部开始 倒叙存放到新数组 // i-- left++ right--
    let newArray = new Array(nums.length),
    left = 0, right = nums.length - 1;
    for (let i = nums.length - 1; i >= 0; i--) {
        if(nums[left] * nums[left] >= nums[right] * nums[right]) {
            newArray[i] = nums[left] * nums[left];
            left++;
        } else {
            newArray[i] = nums[right] * nums[right];
            right--;
        }
    }
    return newArray;
};
```

**167. 两数之和 II - 输入有序数组**

Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.

<img src="../../assets/image-20230829211700586.png" alt="image-20230829211700586" style="zoom:30%;" />





-  https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
-  https://leetcode.com/problems/remove-duplicates-from-sorted-array/
-  https://leetcode.com/problems/squares-of-a-sorted-array/
-  https://leetcode.com/problems/3sum/ (Blind)
-  https://leetcode.com/problems/3sum-closest/
-  https://leetcode.com/problems/3sum-smaller/
-  https://leetcode.com/problems/subarray-product-less-than-k/
-  https://leetcode.com/problems/sort-colors/
-  https://leetcode.com/problems/4sum/
-  https://leetcode.com/problems/backspace-string-compare/
-  https://leetcode.com/problems/shortest-unsorted-continuous-subarray/



**1 二分查找**

**2 两数之和**

167 两数之和 II



**3 反转数组**

344 反转字符串



**4 回文串判断**

5  最长回文子串





## 题目

125 验证回文串

16 最接近的三数之和

151 反转字符串中的单词

680 验证回文串 II



剑指 Offer 57. 和为s的两个数字	

剑指 Offer II 006. 排序数组中两个数字之和



