## 1、类型转换

**字符串转数组**

```js
let str = "hello";

// 1 String.split(separator, limit)
let arr = str.split(""); // arr = [h, e, l, l, o]
let arr = str.split("", 3); // arr = [ 'h', 'e', 'l' ]

// 2 Array.from(arrayLike, mapFn, thisArg) 从可迭代或类数组对象创建一个新的浅拷贝的数组实例
let arr = Array.from(str); // arr = [h, e, l, l, o]
console.log(Array.from([1, 2, 3], (x) => x + x)); // Array [2, 4, 6]

// 3 扩展运算符
let arr = [...str]; // arr = [h, e, l, l, o]
```

**数组转字符串**

```js
// 1 toString()
[1, 2, 'a', '1a'].toString(); // "1,2,a,1a"

// 2 Array.join(separator) 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串
['Fire', 'Air', 'Water'].join('-'); // "Fire-Air-Water"

// 3 String() 构造函数
let string = String( array ); //explicit coercion
let string = " " + array //implicit coercion
```

**字符串转数字**

```js
// 1 Number() function
console.log(Number('12')); // 12
console.log(Number('12.12')); // 12.12
console.log(Number('a')); // NaN

// 2 parseInt(string, radix) function
console.log(parseInt('12')); // 12
console.log(parseInt('12.12')); // 12
// 3 parseFloat(string) function
console.log(parseFloat('12')); // 12
console.log(parseFloat('12.12')); // 12.12

// 4 plus operator (+)
console.log(+'12'); // 12
// 5 multiplying the string by the number 1
console.log(1 * '12'); // 12
// 6 dividing the string by the number 1
console.log('12' / 1); // 12
// 7 subtracting the number 0 from the string
console.log('12' - 0); // 12

// 8 Math.floor() function rounds down 向下取
console.log(floor('5.95')); // 5
console.log(floor('5')); // 5
console.log(floor('-5.05')); // -6
 
// 9 Math.ceil() function rounds up 向上取
console.log(ceil('0.95')); // 1
console.log(ceil('1')); // 1
console.log(ceil('-7.004')); // -7

// 10 Math.round() function 四舍五入
console.log(Math.round(5.95), Math.round(5.5), Math.round(5.05)); // Expected output: 6 6 5
console.log(Math.round(-5.05), Math.round(-5.5), Math.round(-5.95));// Expected output: -5 -5 -6
```

**数字转字符串**

```js
// 1 toString()
console.log((50).toString());

// 2 String() Constructor
console.log(String(50)); 
```

**对象转数组**

```js
const person = {
    firstName: 'John',
    lastName: 'Doe'
};

// 1 Object.entries(obj)
const entries = Object.entries(person); // [ [ 'firstName', 'John' ], [ 'lastName', 'Doe' ] ]

// 2 Object.keys(obj)
const propertyNames = Object.keys(person); // [ 'firstName', 'lastName' ]

// 3 Object.values(obj)
const propertyValues = Object.values(person); // [ 'John', 'Doe' ]
```

**数组转对象**

```js
const props = [
  ['name', 'Sling Academy'],
  ['color', 'green']
];

// 1 解构赋值
const obj1 = {...props}; // {'0': [ 'name', 'Sling Academy' ],'1': [ 'color', 'green' ]}
// 2 Object.assign()
const obj2 = Object.assign({}, props); // 同上

// 3 Object.fromEntries()
const obj3 = Object.fromEntries(props); // { name: 'Sling Academy', color: 'green'}
// 4 Array.forEach()
const obj4 = {}
props.forEach(elem => obj4[elem[0]] = elem[1]); // 同上
```

## 2、解构赋值

- ES6 允许按照一定模式，从**数组和对象（可遍历的结构）**中提取值，对变量进行赋值。对象的解构与数组有一个重要的不同。
- 数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
- 等号右边的值不是对象或数组，就先将其转为对象。
- 如果解构不成功，变量的值就等于`undefined`。
- 只有当一个数组成员严格等于`undefined`，**默认值**才会生效。

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];// foo=1 bar=2 baz=3  模式匹配
let [a, [b], d] = [1, [2, 3], 4]; // b=2  不完全解构
let [ , , third] = ["foo", "bar", "baz"]; // third="baz"  ,隔开
let [x, y, ...z] = ['a']; // x="a" y=undefined z=[]  如果解构不成功，变量的值就等于undefined，...z默认为数组
let [x, y, z] = new Set(['a', 'b', 'c']); // x="a" 右边是可遍历结构

let [x = 1, y = x] = [2]; // x=2; y=2 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
let [x = f()] = [1]; // 表达式是惰性求值的，即只有在用到的时候，才会求值。
```

**扩展运算符（`...`）**

- 若 `...` 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中**剩余的参数收集到一个数组/对象中**。—— 在左边

  ```js
  let [head, ...tail] = [1, 2, 3, 4]; // head=1 tail=[2, 3, 4]
  let {head, ...tail} = {tail: 'tail', a: 'a', b: 'b', c: 'c', head: 'head'}; 
  console.log(tail, head); // { tail: 'tail', a: 'a', b: 'b', c: 'c' } head
  
  // rest 参数：用于获取函数的多余参数，这样就不需要使用arguments对象（不是数组）
  function add(array, ...values) {} // values是数组，成员是传入函数的参数
  (function(a, ...b) {}).length  // 1，函数的length属性，不包括 rest 参数
  ```

- 若 `...` 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会**把一个数组/对象展开**。—— 在右边

  ```js
  // Spread 语法
  function f(v, w, x, y, z) { }
  const args = [0, 1];
  f(-1, ...args, ...[3], ...(x > 0 ? ['a'] : ['b'])); // 扩展运算符后面还可以放置表达式
  [...[], 1] // [1] 如果扩展运算符后面是一个空数组，则不产生任何效果。
  
  const person = {
      firstName: 'John',
      lastName: 'Doe'
  };
  const obj = {...person}; // { firstName: 'John', lastName: 'Doe' } 
  // const obj1 = [...person]; // 报错 person不是可迭代对象
  
  const arr = ["Sling", "Academy", "JavaScript", "Tutorial"];
  const obj2 = [...arr]; // [ 'Sling', 'Academy', 'JavaScript', 'Tutorial' ]
  const obj3 = {...arr}; // { '0': 'Sling', '1': 'Academy', '2': 'JavaScript', '3': 'Tutorial' }
  ```

