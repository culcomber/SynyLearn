## 1、需求分析和架构设计

### 1.1 项目结构

- 前端 (`SPA` 项目，使用 `Vue` 或者 `React`) --> `lego`
  - 编辑器(`lego-editor`)
  - 其他页面(`lego-pages`)
- 后端 --> `lego-backend`
  - `RESTful API`
  - `H5` 页面 `SSR`(`Server side rendering`)
- 组件库 --> `lego-components`

==其他页面 nest ssr==

<img src="../../assets/image-20240221223754924.png" alt="image-20240221223754924" style="zoom:50%;" />

### 1.2 项目难点

海报的组成

- 背景，由图片或者纯色组成
- 元素
  - 由各种不同的元素(组件) 组成
  - 一部分属性界定它的位置 (`position`)
  - 一部分属性界定它的展示 (`looks`)

数据结构设计

- 向画布添加组件或者删除组件(向 `components` 数组添加或者删除特定的组件）

- 更新组件的某个属性(找到对应的 `component`，然后更新它的 `props`

- 渲染画布或者作品(循环保存的作品信息，使用每个组件特定的属性进行渲染)

扩展性-场景设计，不要关注细节，技术方案设计，为的就是寻找一个方向，论证:可行性、扩展性、复杂度高低

- 海报添加对应的背景音乐
- 新的组件类型-比如说当前日期

<img src="../../assets/image-20240221224150272.png" alt="image-20240221224150272" style="zoom:40%;" />

<img src="../../assets/image-20240221224224828.png" alt="image-20240221224224828" style="zoom:50%;" />

### 1.3 研发流程优化

<img src="../../assets/image-20240221230530456.png" alt="image-20240221230530456" style="zoom:50%;" />

**开发模式**

<img src="../../assets/image-20240222231318438.png" alt="image-20240222231318438" style="zoom:70%;" />

**前端监控体系**

前端监控的三个阶段

- 初阶：使用第三方平台，百度、友盟、阿里云 `ARMS` 等
- 中阶：自研前端监控库，缺乏完整的监控体系
- 高阶：自研前端监控平台，具备完整的监控体系

前端监控的数据作用

- 流量数据监控，如：`PV`、`UV`、点击率、页面停留时长等
- 自定义事件监控，如：曝光事件、滑动事件、请求事件等
- 交易指标监控，如：成交额、转化率等
- 其他综合分析，如：用户画像分析、流量漏斗、销量预测等

**项目测试体系**

前端项目测试

- 测试同学：功能测试，性能测试，测试用例
- 前端同学：单元测试，常用于组件库、`API` 等(`Jest`、`Mocha`)

上线项目测试

- 测试同学回归
- 利用前端监控，进行监控项目稳定性和性能，并上报前端日志
  - 稳定性：如 `iserror`、白屏检测等
  - 性能：如秒开率、首屏渲染时长、接口请求时长等
  - 前端日志：如 `console.log`、`API` 请求记录等

**前端发布体系**

利用脚手架统一管理发布阶段

- 利用脚手架做发布的优势
  - 规范：利用统一发布规范，如 `commit` 记录、分支名称、代码规范等
  - 效率：避免大量重复操作，浪费开发时间
  - 安全：构建和发布全部在云端操作，避免个人发布时带来的安全隐患
- 脚手架发布的流程
  - `GitFlow` 自动化代码提交
  - 远程代码自动检查
  - 云端完成构建与发布操作

<img src="../../assets/image-20240222231938880.png" alt="image-20240222231938880" style="zoom:80%;" />

<img src="../../assets/image-20240222232403759.png" alt="image-20240222232403759" style="zoom:100%;" />

## 2、脚手架架构设计和框架搭建

将收获什么
。脚手架的实现原理
。`Lerna` 的常见用法
。架构设计技巧和架构图绘制方法
主要内容
。学习如何以架构师的角度思考基础架构问题
。多 `Package` 项目管理痛点和解决方案，基于`Lerna` 脚手架框架搭建
。`imooc-cli` 脚手架需求分析和架构设计，架构设计图
附赠内容
。脚手架调试技巧
。`Lerna` 源码分析
。`Node` 的 `module` 模块分析
。`yargs` 使用方法
。剖析 `Lerna` 架构设计
关键词
。脚手架：掌握脚手架原理和开发全流程
。`Lerna`：解决多 `Package`项目管理痛点
。架构设计：学习大厂基础架构设计思路
学习方法
。架构三部曲: 掌握原理 -> 独立思考 -> 总结反思
。深度剖析优秀开源项目，由表及里，由浅入深
。视角切换：多切换到架构师视角，从全局思考问题

### 2.1 脚手架开发入门

#### 2.1.1 脚手架的必要性

脚手架核心价值：提升前端研发效能，将研发过程：

- 自动化：项目重复代码拷贝/ `git` 操作/发布上线操作

- 标准化：项目创建/ `gitflow` /发布流程/回滚流程
- 数据化：研发过程系统化、数据化，使得研发过程可量化

和自动化构建工具区别

问题：`jenkins`、`travis` 等自动化构建工具已经比较成熟了，为什么还需要自研脚手架?

- 不满足需求：`jenkins`、`travis` 通常在 `git hooks` 中触发，需要在服务端执行，无法覆盖研发人员本地的功能如:创建项目自动化、本地git操作自动化等
- 定制复杂：`jenkins`、`travis` 定制过程需要开发插件，其过程较为复杂，需要使用Java语言，对前端同学不够友好

<img src="../../assets/image-20240225190413496.png" alt="image-20240225190413496" style="zoom:40%;" />

#### 2.1.2 理解脚手架

脚手架本质是一个操作系统的客户端，它通过命令行执行

`vue create vue-test-app`，表示创建一个 `vue` 项目，项目的名称为 `vue-test-app`，命令由 3个部分组成:

- 主命令: `vue`
- `command`: `create`
- `command`的`param`: `vue-test-app`

`vue create vue-test-app --force`，表示当前目录已经有文件了，需要覆盖当前目录下的文件

- `--force` 是 `option`，用来辅助脚手架确认在特定场景下用户的选择(可以理解为配置)

`vue create vue-test-app --force -r https://registry.npm.taobao.org`，表示安装依赖使用淘宝源

-  `-r` 也是  `option`，它与 `--force` 不同的是它使用 `-`，表示使用简写，这里的 `-r` 也可以替换成 `--registry`
- `https://reqistry.npm.taobao.org` 成为`option` 的`param``
- `--force` 可以理解为：`--force true`，简写为：`--force` 或 `-f`

**脚手架的执行原理**

<img src="../../assets/image-20240225203118473.png" alt="image-20240225203118473" style="zoom:40%;" />

**脚手架的执行源理如下:**

- 在终端输入 `vue create vue-test-app`

- 终端解析出 `vue` 命令

- 终端在环境变量中找到 `vue` 命令（`where vue`）

  <img src="../../assets/image-20240226131425973.png" alt="image-20240226131425973" style="zoom:33%;" />

- 终端根据 `vue` 命令链接到实际文件 `vue.js`（上图）

- 终端利用 `node` 执行 `vue.js`

- `vue.js` 解析 `command/options`

- `vue.js` 执行 `command`

- 执行完毕，退出执行

**从应用的角度看开发脚手架**

- 开发 `npm` 项目，该项目中应包含一个 `bin/vue.js` 文件，并将这个项目发布到 `npm`
- 将 `npm` 项目安装到 `node` 的 `lib/node modules`
- 在 `node` 的 `bin` 目录下配置 `vue` 软链接指向 `lib/node modules/@vue/cli/bin/vue.js`，在执行 `vue` 命令的时候就可以找到 `vue.js` 进行执行

#### 2.1.3 脚手架的实现原理

**脚手架实现原理**

如果你能回答以下3个问题，就掌握了脚手架的实现原理:

1. 为什么全局安装 `@vue/cli` 后会添加的命令为 `vue`? 

   `bin/vue` 软链接指定了 `vue` 命令

   <img src="../../assets/image-20240226130339444.png" alt="image-20240226130339444" style="zoom:33%;" />

   项目中 `bin` 配置了 软连接名称以及实际运行文件的位置

   <img src="../../assets/image-20240226130055674.png" alt="image-20240226130055674" style="zoom:33%;" />

2. 全局安装 `@vue/cli` 时发生了什么?

   安装包到 `node/lib/node modules`

   在`node/bin` 中按照 `package.json` 文件中 `bin` 配置软链接

3. 执行 `vue` 命令时发生了什么?为什么 `vue` 指向一个 `js` 文件，我们却可以直接通过 `vue` 命令去执行它?

   在环境变量中找 `node` 命令，找到后使用  `node`  执行文件

   <img src="../../assets/image-20240226132601293.png" alt="image-20240226132601293" style="zoom:50%;" />

   <img src="../../assets/image-20240226131113208.png" alt="image-20240226131113208" style="zoom:50%;" />

4. 为什么说脚手架本质是操作系统的客户端?它和我们在PC上安装的应用/软件有什么区别?

   `node` 是客户端，编写的代码在 `node`  环境中执行

5. 如何为 `node` 脚手架命令创建别名?

   在 `node/bin`  目录下创建软链接

6. 脚手架命令执行的全过程

   <img src="../../assets/image-20240225203746041.png" alt="image-20240225203746041" style="zoom:30%;" />

#### 2.1.4 脚手架的开发流程

**开发流程**

- 创建 `npm` 项目
- 创建脚手架入口文件，最上方添加: `#!/usr/bin/env node`
- 配置 `package.json`，添加 `bin` 属性
- 编写脚手架代码
- 将脚手架发布到 `npm`

**使用流程**

- 安装脚手架 `npm install -g your-own-cli`
- 使用脚手架 `your-own-cli`

**脚手架开发难点解析**

- 分包：将复杂的系统拆分成若干个模块

- 命令注册：`vue create`  `vue add`  `vue invoke`

- 参数解析：`vue command [options]<params>`

  - `options `全称：`--version`、`--help`
  - `options` 简写：`-v`、`-h`
  - 带 `params` 的 `options`：`--path /Users/sam/Desktop/vue-test`
  
- 帮助文档：

  - `global help`：`Usage`、`Options`、`Commands`
  - `commands  help`：`Usage`、`Options`


- 命令行交互
- 日志打印
- 命令行文字变色
- 网络通信：`HTTP/WebSocket`
- 文件处理

#### 2.1.5 第一个脚手架

`npm init -y` 初始化项目后，创建下面目录结构

<img src="../../assets/image-20240226231805764.png" alt="image-20240226231805764" style="zoom:80%;" />

```js
// bin/index.js
#!/usr/bin/env node
console.log('welcome imooc-test');

// package.json 添加命令
{
  "bin": {
    "imooc-test": "bin/index.js"
  }
}
```

`npm publish` 发布包

#### 2.1.6 调试脚手架

在项目路径下输入`npm link` ，在 `node/bin` 创建命令，将项目创建快捷方式放到`node/lib/node modules`目录下，命令行执行`imooc-test`，最终执行到项目

<img src="../../assets/image-20240227125441570.png" alt="image-20240227125441570" style="zoom:50%;" />

<img src="../../assets/image-20240227125503230.png" alt="image-20240227125503230" style="zoom:50%;" />

<img src="../../assets/image-20240227125222046.png" alt="image-20240227125222046" style="zoom:50%;" />

**本地项目之间调试**

1. 创建一个新项目如下

   <img src="../../assets/image-20240227130559380.png" alt="image-20240227130559380" style="zoom:50%;" />

2. `imooc-test-lib` 文件内容

   ```js
   // index.js`
   module.exports = {
     sam(a, b) {
       return a + b;
     }
   }
   
   // package.json 配置入口文件
   "main": "lib/index.js",
   ```

3. `imooc-test`  使用  `imooc-test-lib` ，本地调试

   - 此时在 `imooc-test` 目录下 `npm link imooc-test-lib-sam` 会报错因为 `imooc-test-lib` 没有发布到 `npm`
   -  `imooc-test-lib`  目录下 `npm link` 
   -  `imooc-test` 目录下 `npm link imooc-test-lib-sam` 

4. `imooc-test`  的 `package.json` 手动添加  `imooc-test-lib` 防止项目上线依赖报错

**脚手架本地 `link` 标准流程**

```shell
# 链接本地脚手架:
cd your-cli-dir
npm link

# 链接本地库文件:
cd your-lib-dir
npm link
cd your-cli-dir
npm link your-lib

# 取消链接本地库文件
cd your-lib-dir
npm unlink
cd your-cli-dir
npm unlink your-lib
rm -rf node modules
npm install -S your-lib
```

理解 `npm link`

- `npm link your-lib`：将当前项目中 `node_modules` 下指定的库文件链接到 `node` 全局 `node modules` 下的库文件
- `npm link`：将当前项目链接到 `node` 全局 `node modules` 中作为一个库文件并解析 `bin` 配置创建可执行文件

理解 `npm unlink`

- `npm unlink`：将当前项目从 `node` 全局 `node modules` 中移除
- `npm unlink your-lib`：将当前项目中的库文件依赖移除

#### 2.1.7 命令注册和参数解析

```js
const argv = require('process').argv;
// console.log(argv);
/*$ imooc-test init --name vue-test
[
  'C:\\Program Files\\nodejs\\node.exe',
  'D:\\Web\\nodejs\\node_global\\node_modules\\imooc-test-sam\\bin\\index.js',
  'init',
  '--name',
  'vue-test'
]*/

// 获取命令行参数
const command = argv[2]; // init or --version
const options = argv.slice(3);

// 解析 imooc-test init --name vue-test
if (options.length > 1) {
  const [option, param] = options; // 数组的解构赋值
  if (command) {
    if (lib[command]) {
      lib[command]({option, param});
    } else {
      console.log('无效的命令');
    }
  } else {
    console.log('请输入命令');
  }
}

// 解析全局命令 imooc-test --version
if (command.startsWith('-')) {
  const globalOption = command.replace(/-|--/g, '');
  if (globalOption === 'version' || globalOption === 'V') {
    console.log('1.0.0');
  }
}
```

#### 2.1.7 发布脚手架

先发布 `imooc-test-lib` 

- `npm unlink` 取消本地 `node` 目录下的链接
- `npm publish`

脚手架 `imooc-test`

- `npm unlink imooc-test-lib`  取消对库文件的依赖
- `npm unlink` 取消本地 `node` 目录下的链接
- `npm publish`
- `npm i -g imooc-test`

<img src="../../assets/image-20240227234654251.png" alt="image-20240227234654251" style="zoom:80%;" />

### 2.2 脚手架框架搭建

2.2.1 `Lerna` 简介

2.2.2 `Lerna` 源码分析



### 2.3 脚手架架构设计

